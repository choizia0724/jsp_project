{"version":3,"sources":["raw-js/kendo.dataviz.core.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","kendodataviz","core","js","this","$","dataviz","services","draw","window","kendo","drawing","util","Path","Group","Class","support","geometry","Rect","Circle","geometryTransform","transform","Segment","deepExtend","isFunction","__common_getter_js","getter","ARC","AXIS_LABEL_CLICK","BLACK","BOTTOM","CENTER","CIRCLE","CROSS","DATE","DEFAULT_FONT","DEFAULT_PRECISION","FORMAT_REGEX","HEIGHT","INSIDE","LEFT","MAX_VALUE","Number","MIN_VALUE","NONE","NOTE_CLICK","NOTE_HOVER","NOTE_LEAVE","OBJECT","OUTSIDE","RIGHT","ROUNDED_RECT","STRING","TOP","TRIANGLE","WHITE","WIDTH","X","Y","constants","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","TAB","ARIA_ACTIVE_DESCENDANT","COORD_PRECISION","DEFAULT_HEIGHT","DEFAULT_WIDTH","END","HIGHLIGHT_ZINDEX","INHERIT","START","SQUARE","RECT","VALUE","DEFAULT_SERIES_OPACITY","POINTER","HORIZONTAL","VERTICAL","isArray","value","Array","addClass","element","classes","classArray","idx","length","className","indexOf","SPACE_REGEX","removeClass","replace","alignPathToPixel","path","offset","options","stroke","defined","width","i","segments","anchor","round","translate","clockwise","angle1","angle2","x","y","isNumber","isNaN","isString","isObject","styleValue","SIZE_STYLES_REGEX","isSizeField","field","test","getSpacing","defaultSpacing","spacing","top","right","bottom","left","current","compile","template","TemplateService","extend","getTemplate","content","grep","array","callback","result","push","register","userImplementation","HashMap","_map","Map","inArray","prototype","get","key","set","TRIGGER","InstanceObserver","init","observer","handlers","handlerMap","trigger","name","args","isDefaultPrevented","callObserver","fnName","len","arguments","apply","requiresHandlers","names","isPlainObject","Object","toString","call","map","browser","ref","append","bindEvents","deg","elementOffset","elementSize","eventCoordinates","eventElement","hashKey","last","limitValue","objectKey","rad","unbindEvents","valueOrDefault","FontLoader","setDefaultOptions","type","proto","fetchFonts","fonts","state","depth","document","keys","forEach","loadFonts","promises","font","load","e","logToConsole","Promise","all","then","preloadFonts","KI_PREFFIX","KSVG_PREFFIX","HTMLBaseIcon","wrapper","addClasses","html","outerHTML","size","themeColor","flip","iconClass","stylingOptions","HTMLFontIcon","fn","currentIconClass","split","find","startsWith","icon","_className","HTMLSvgIcon","innerHTML","iconNameMatch","match","toUpperCase","svgIcons","setAttribute","svgElement","createElementNS","viewBox","appendChild","ICON_TYPES","svg","sparseArrayLimits","arr","min","max","isFinite","Math","undefined","Matrix","matrixRegexp","transformMatrix","getComputedStyle","unit","matrixString","members","parseFloat","Function","bind","concat","parseMatrix","autoTextColor","color","Color","isDark","DELETED","LegacySet","values","_index","_values","slice","filter","item","has","add","delete","index","clear","defineProperties","SetWrapper","_set","Set","from","Matrix$1","height","data","clone","m","row","col","line","each","f","includeEmpty","val","el","transpose","n","a","j","multiply","b","s","va","vb","inverse","augment","loop","k","imax","start","end","pos","v","argmax","tmp","returned","i$1","j$1","k$1","i$2","j$2","ret","autoMajorUnit","diff","abs","scale","pow","floor","log","relativeValue","Point","equals","point","rotate","center","degrees","theta","cosT","cos","sinT","sin","cx","cy","distanceTo","dx","dy","sqrt","onCircle","angle","radius","radians","Box","x1","y1","x2","y2","box","move","wrap","targetBox","wrapPoint","arrayPoint","snapTo","axis","alignTo","targetCenter","shrink","dw","dh","expand","pad","padding","unpad","containsPoint","points","getHash","join","overlaps","rotation","r1","rotatePoint","r2","r3","r4","toRect","hasSize","align","alignment","c1","c2","sizeFunc","Ring","innerRadius","startAngle","middle","setRadius","newRadius","radianAngle","ax","ay","adjacentBox","distance","sector","midAndle","midPoint","hw","hh","sa","ca","p","endAngle","vector","startPoint","startVector","endPoint","endVector","dist","getBBox","angles","allAngles","sort","numericComparer","startAngleIndex","endAngleIndex","Sector","ShapeBuilder","createRing","arc","Arc","radiusX","radiusY","fromArc","close","innerEnd","pointAt","lineTo","ChartElement","children","initUserOptions","reflow","currentChild","destroy","animation","getRoot","parent","getSender","service","getService","sender","chartService","translateChildren","childrenCount","arguments$1","renderVisual","visible","createVisual","addVisual","renderChildren","createAnimation","renderComplete","visual","chartElement","appendVisual","zIndex","Animation","create","childVisual","noclip","clipRoot","stackRoot","stackVisual","isStackRoot","visuals","sibling","insert","traverse","child","closest","matched","hasHighlight","highlight","createHighlight","toggleHighlight","show","opacity","this$1$1","customVisual","_highlight","highlightOptions","fill","highlightVisualArgs","series","dataItem","category","percentage","runningTotal","total","toggleFocusHighlight","accessibility","focusHighlight","_focusHighlight","highlightColor","background","focusHighlightOptions","border","createFocusHighlight","createGradientOverlay","gradientOptions","overlay","createGradient","closed","elements","supportsPointInactiveOpacity","BoxElement","margin","shrinkToFit","hasSetSize","borderWidth","reflowPaddingBox","vAlign","paddingBox","contentBox","hasBox","fromRect","visualStyle","dashType","cursor","ShapeElement","pointData","getElement","halfWidth","halfHeight","style","fromPoints","MultiPath","moveTo","rect","borderRadius","setCornerRadius","createElement","visualOptions","accessibilityOptions","role","ariaLabel","ariaRoleDescription","ariaChecked","RADIAL","GRADIENTS","glass","stops","sharpBevel","roundedBevel","roundedGlass","supportVML","sharpGlass","bubbleShadow","boxDiff","r","c","d","g","h","boxes","RootElement","rootOptions","parseInt","gradients","currentBox","createBackground","drawingGradient","hashCode","gradient","LinearGradient","usedSpace","currentStops","currentStop","innerRadialStops","RadialGradient","cleanGradients","_observers","FloatElement","_initDirection","vertical","groupAxis","elementAxis","groupSizeField","elementSizeField","groupSpacing","elementSpacing","vSpacing","reflowChildren","ref$1","groupOptions","groups","groupsSize","maxGroupElementsSize","groupsCount","groupsStart","alignStart","groupStart","groupIdx","group","groupElements","elementStart","groupElementsCount","elementSize$$1","groupElementStart","groupSize","elementBox","maxSize","groupElementsSize","DrawingText","Text","measureText","baseline","topLeft","rectToBox","origin","bottomRight","ROWS_SPLIT_REGEX","TextBox","_initContainer","_autoReflow","rows","String","floatElement","textOptions","container","rowIdx","text","trim","visualFn","_boxReflow","visualBox","visualContext","clippedBBox","normalBox","rotatedBox","rotationTransform","context","getDefaultVisual","boxCenter","Title","_textBox","position","collapseVerticalMargins","items","prevBox","buildTitle","defaultOptions","title","titleOptions","orderTitles","titles","reverse","AxisLabel","format","culture","click","widget","alignRotation","bbox","matrix","rotationMatrix","rotationOrigin","alignAxis","distanceAxis","axisAnchor","transformCopy","topRight","bottomLeft","alignEnd","distanceLeft","distanceRight","alignCenter","Note","fields","render","hide","label","childAlias","noteTemplate","auto","aliasFor","marker","wrapperBox","lineStart","linePoints","createLine","defaultVisual","eventArgs","preventDefault","over","out","current$1","parseDate","Date","firstDay","IntlService","implementation","FORMAT_REPLACE_REGEX","FormatService","intlService","_intlService","formatString","intl","localeAuto","locale","placeholderFormat","substring","current$2","ChartService","chart","rtl","Boolean","notify","isPannable","pannable","lock","DomEventsBuilder","events","createAxisTick","tickOptions","tickX","tickY","tick","createAxisGridLine","gridLine","lineEnd","Axis","labels","majorTickSize","minorTickSize","minorTicks","minorTickType","majorTicks","majorTickType","initFields","_deferLabels","createLabels","createTitle","createNotes","labelsRange","skip","labelsCount","normalizeLabelRotation","labelOptions","step","clearLabels","autoRotateLabels","range","labelContext","count","createAxisLabel","clearTitle","lineBox","mirror","axisX","axisY","lineWidth","visualSize","notes","parseNoteValue","note","createPlotBands","gridLinesVisual","gridLines","_gridLines","createTicks","lineGroup","majorUnit","tickLineOptions","tickPositions","skipUnit","getMajorTickPositions","getMinorTickPositions","minorUnit","_alignLines","_lineGroup","getActualTickSize","tickSize","_backgroundPath","plotBands","plotArea","_plotbandGroup","altAxis","pane","axes","slotX","slotY","getSlot","to","createPlotBandLabel","bandRect","textbox","labelTemplate","createGridLines","minorGridLines","majorGridLines","axisLineVisible","linePos","lineOptions","sizeFn","titleSize","space","boxSize","maxLabelSize","labelSize","arrangeTitle","arrangeLabels","arrangeNotes","getLabelsTickPositions","labelTickIndex","labelsBetweenTicks","tickIx","firstTickPosition","nextTickPosition","positionStart","positionEnd","positionLabel","labelBox","labelOffset","labelX","labelY","autoRotateLabelAngle","slotWidth","limit","labelAngle","idx$1","slot","shouldRenderNote","noteSlot","secondAxis","axisLabelText","tmpl","defaultText","maxLabelOffset","lastLabel","offsetField","startPosition","endPosition","maxStartOffset","maxEndOffset","startTick","endTick","limitRange","rangeSize","minValue","maxValue","valueRange","seriesMin","seriesMax","lineDir","lineInfo","lineSize","axisDir","axisOrigin","pointOffset","scaleToDelta","rawScale","justified","prepareUserOptions","axisCrossingValue","MILLISECONDS","SECONDS","MINUTES","HOURS","DAYS","WEEKS","MONTHS","YEARS","TIME_PER_SECOND","TIME_PER_MINUTE","TIME_PER_HOUR","TIME_PER_DAY","TIME_PER_WEEK","TIME_PER_MONTH","TIME_PER_YEAR","TIME_PER_UNIT","years","months","weeks","days","hours","minutes","seconds","milliseconds","absoluteDateDiff","getTime","getTimezoneOffset","addTicks","date","ticks","toDate","startOfWeek","weekStartDay","daysToSubtract","day","getDay","adjustDST","getHours","setHours","addDuration","dateValue","getFullYear","getMonth","getDate","roundedDate","setMinutes","tzDiff","addHours","getSeconds","setSeconds","getMilliseconds","setMilliseconds","floorDate","ceilDate","dateComparer","dateDiff","toTime","dateEquals","timeIndex","baseUnit","dateIndex","baseUnitStep","startDate","duration","parseDates","dates","CategoryAxis","_ticks","categoriesHash","copy","categories","srcCategories","definedMin","definedMax","ceil","rangeIndices","totalRange","roundedRange","_seriesMax","scaleOptions","hideOutOfRangeLabels","valueAxis","firstLabel","getTicks","labelTicks","tickIndices","stepSize","indices","getTickPositions","positions","cache","hash","_hash","hasMinor","filterOutOfRangePositions","inRange","startIndex","endIndex","slotBox","singleSlot","p1","p2","limitSlot","limittedSlot","categoryIndex","pointCategoryIndex","startValue","getCategory","totalIndex","categoryAt","categoriesCount","translateRange","delta","scaleRange","limitedRangeIndices","minDelta","maxDelta","zoomRange","totalMin","totalMax","dataItems","hideOutOfRangeNotes","pan","pointsRange","diffStart","diffEnd","rangeMin","rangeMax","_categoriesMap","currentRangeIndices","totalCount","totalLimit","totalRangeIndices","indexCategories","map$$1","COORDINATE_LIMIT","DateLabelFormats","ZERO_THRESHOLD","BASE_UNITS","FIT","categoryRange","clearCache","_range","EmptyDateRange","displayIndices","displayRange","valueIndex","valuesCount","dateAt","DateRange","roundToBaseUnit","lowerEnd","roundToTotalStep","expandEnd","justifyEnd","valueStart","displayStart","next","valueEnd","displayEnd","_indices","minIdx","maxIdx","upper","roundedStep","autoBaseUnit","startUnit","startStep","unitSteps","nextStep","categoryLimits","span","autoBaseUnitSteps","maxDateGroups","autoUnit","autoUnitIx","units","totalUnits","shift","initUnit","toLowerCase","lastCategory","minDiff","categoryIx","defaultBaseUnit","DateCategoryAxis","dataRange","_parsed","panning","userSetBaseUnit","userSetBaseUnitStep","maxDivisions","safeOptions","forecast","_forecast","before","after","divisionOptions","dataRangeOptions","divisionRange","rangeLabels","last$$1","splice","isEmpty","totalLimits","panRange","datesRange","indicesRange","fit","autoBaseUnitStep","maxDiff","rangeDiff","baseUnitIndex","stepIndex","createRangeLabels","arrangeRangeLabels","position$1","autoRotateRangeLabels","hideOverlappingLabels","firstRangeLabel","clip","lastRangeLabel","rangeLabel","unitFormat","dateFormats","createLabel","rotateLabel","dateRange","limitCoordinate","MIN_VALUE_RANGE$1","NumericAxis","autoOptions","narrowRange","autoMin","narrow","axisMin","autoAxisMin","autoMax","axisMax","autoAxisMax","roundToMajorUnit","remainderClose","autoAxisOptions","totalOptions","totalAxisOptions","userOptions","userSetMin","userSetMax","clearNullValues","userSetLimits","axisOptions","totalMajorUnit","getDivisions","stepValue","divisions","skipStep","getValue","endValue","isValidRange","divisor","ratio","remainder","DateValueAxis","timeUnits","baseUnitTime","userMajorUnit","actualUnits","unitsToAdd","head","tail","applyDefaults","axisCrossingValues","dir","limittedRange","MIN_VALUE_RANGE$2","LogarithmicAxis","base","logMaxRemainder","autoAxisMax$1","autoAxisMin$1","throwNegativeValuesError","initRange","logMin","logMax","floorMax","traverseMajorTicksPositions","tickPosition","traverseMinorTicksPositions","power","minorOptions","_minorIntervalOptions","minorStep","info","Error","GridLinesMixin","majorAngles","minorAngles","skipMajor","majorGridLineAngles","renderMajorGridLines","minorGridLineAngles","renderMinorGridLines","renderGridLines","radiusCallback","circle","gridLineAngles","skipAngles","divs","intervals","altAxisVisible","alpha","intervalAngle","RadarCategoryAxis","reflowLabels","measureBox","skipOption","stepOption","divCount","divAngle","majorIntervals","minorIntervals","interval","minorAngle","minorRadius","band","plotBandSlot","ring","totalDivs","slotAngle","fromValue","slotStart","PolarAxis","instanceOptions","atan2","PI","RadarNumericAxisMixin","polarAxis","bandStyle","shape","plotBandPoints","innerPoints","outerPoints","innerCircle","outerCircle","radarMajorGridLinePositions","radarMinorGridLinePositions","tickRadius","angleIx","angularDistance","gamma","beta","axisType","RadarNumericAxis","minorSkipStep","RadarLogarithmicAxis","CurveProcessor","process","dataPoints","removeDuplicates","initialControlPoint","lastControlPoint","p0","pop","tangent","controlOut","firstControlPoint","secondControlPoint","controlPoints","tangent$1","cp0","controlPoints$1","cp1","controlPoints$2","tangent$2","invertAxis","lineFunction","calculateFunction","isLine","xField","yField","restrict","switchOrientation","monotonic","isMonotonicByField","numberSign","oldXField","restrictControlPoint","cp","p3","t1","t2","xValue","yValue","controlPoint","Gradients","convertableToNumber","cycleUp","cycleDown","cycleIndex","elementStyles","styles","stylesArray","field$1","getAriaTemplate","ariaTemplate","ariaContent","hasClasses","classNames","interpolateValue","progress","mousewheelDelta","wheelDelta","webkit","devicePixelRatio","detail","renderIcon","iconElement","iconOptions","HTMLElement","predicate","elementScale","parentElement","parentMatrix","multiplyCopy","createHashSet","supported","defaultErrorHandler","error","INSERT","DELETE","BACKSPACE","ENTER","ESC","UP","DOWN","HOME","SPACEBAR","PAGEUP","PAGEDOWN","F2","F10","F12","NUMPAD_PLUS","NUMPAD_MINUS","NUMPAD_DOT","hasOwnProperty","obj","property","lteDateIndex","sortedDates","low","high","currentDate","jQuery","SASS_THEMES","ExportMixin","skipLegacy","exportVisual","exportSVG","exportImage","exportPDF","imageDataURL","Surface","exportGroup","canvas","css","display","appendTo","body","surface","image","_rootElement","toDataURL","remove","calendars","standard","Point2D","Box2D","mwDelta","originalEvent"],"mappings":"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","file":"kendo.dataviz.core.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('kendo.core.js'), require('kendo.drawing.js')) :\n    typeof define === 'function' && define.amd ? define(['kendo.core', 'kendo.drawing'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.kendodataviz = global.kendodataviz || {}, global.kendodataviz.core = global.kendodataviz.core || {}, global.kendodataviz.core.js = factory()));\n})(this, (function () {\n    /***********************************************************************\n     * WARNING: this file is auto-generated.  If you change it directly,\n     * your modifications will eventually be lost.  The source code is in\n     * `kendo-charts` repository, you should make your changes there and\n     * run `src-modules/sync.sh` in this repository.\n     */\n\n    (function($) {\n    /* eslint-disable space-before-blocks, space-before-function-paren, curly, object-curly-spacing */\n\n    window.kendo.dataviz = window.kendo.dataviz || {};\n    var drawing = kendo.drawing;\n    var util = drawing.util;\n    var Path = drawing.Path;\n    var Group = drawing.Group;\n    var Class = kendo.Class;\n    var support = kendo.support;\n    var geometry = kendo.geometry;\n    var Rect = geometry.Rect;\n    var Circle = geometry.Circle;\n    var geometryTransform = geometry.transform;\n    var Segment = geometry.Segment;\n    var dataviz = kendo.dataviz;\n\n    var deepExtend = kendo.deepExtend;\n    var isFunction = kendo.isFunction;\n    var __common_getter_js = kendo.getter;\n\n    var ARC = \"arc\";\n    var ARROW_UP = \"ArrowUp\";\n    var ARROW_DOWN = \"ArrowDown\";\n    var ARROW_LEFT = \"ArrowLeft\";\n    var ARROW_RIGHT = \"ArrowRight\";\n    var TAB = \"Tab\";\n    var ARIA_ACTIVE_DESCENDANT = \"aria-activedescendant\";\n    var AXIS_LABEL_CLICK = \"axisLabelClick\";\n    var BLACK = \"#000\";\n    var BOTTOM = \"bottom\";\n    var CENTER = \"center\";\n    var CIRCLE = \"circle\";\n    var COORD_PRECISION = 3;\n    var CROSS = \"cross\";\n    var DATE = \"date\";\n    var DEFAULT_FONT = \"12px sans-serif\";\n    var DEFAULT_HEIGHT = 400;\n    var DEFAULT_PRECISION = 10;\n    var DEFAULT_WIDTH = 600;\n    var END = \"end\";\n    var FORMAT_REGEX = /\\{\\d+:?/;\n    var HEIGHT = \"height\";\n    var HIGHLIGHT_ZINDEX = 100;\n    var INSIDE = \"inside\";\n    var INHERIT = \"inherit\";\n    var LEFT = \"left\";\n    var MAX_VALUE = Number.MAX_VALUE;\n    var MIN_VALUE = -Number.MAX_VALUE;\n    var NONE = \"none\";\n    var NOTE_CLICK = \"noteClick\";\n    var NOTE_HOVER = \"noteHover\";\n    var NOTE_LEAVE = \"noteLeave\";\n    var OBJECT = \"object\";\n    var OUTSIDE = \"outside\";\n    var RIGHT = \"right\";\n    var ROUNDED_RECT = \"roundedRect\";\n    var START = \"start\";\n    var STRING = \"string\";\n    var TOP = \"top\";\n    var TRIANGLE = \"triangle\";\n    var SQUARE = \"square\";\n    var RECT = \"rect\";\n    var VALUE = \"value\";\n    var WHITE = \"#fff\";\n    var WIDTH = \"width\";\n    var X = \"x\";\n    var Y = \"y\";\n    var DEFAULT_SERIES_OPACITY = 1;\n    var POINTER = \"pointer\";\n    var HORIZONTAL = \"horizontal\";\n    var VERTICAL = \"vertical\";\n\n    var constants = {\n    \tARC: ARC,\n    \tARROW_UP: ARROW_UP,\n    \tARROW_DOWN: ARROW_DOWN,\n    \tARROW_LEFT: ARROW_LEFT,\n    \tARROW_RIGHT: ARROW_RIGHT,\n    \tTAB: TAB,\n    \tARIA_ACTIVE_DESCENDANT: ARIA_ACTIVE_DESCENDANT,\n    \tAXIS_LABEL_CLICK: AXIS_LABEL_CLICK,\n    \tBLACK: BLACK,\n    \tBOTTOM: BOTTOM,\n    \tCENTER: CENTER,\n    \tCIRCLE: CIRCLE,\n    \tCOORD_PRECISION: COORD_PRECISION,\n    \tCROSS: CROSS,\n    \tDATE: DATE,\n    \tDEFAULT_FONT: DEFAULT_FONT,\n    \tDEFAULT_HEIGHT: DEFAULT_HEIGHT,\n    \tDEFAULT_PRECISION: DEFAULT_PRECISION,\n    \tDEFAULT_WIDTH: DEFAULT_WIDTH,\n    \tEND: END,\n    \tFORMAT_REGEX: FORMAT_REGEX,\n    \tHEIGHT: HEIGHT,\n    \tHIGHLIGHT_ZINDEX: HIGHLIGHT_ZINDEX,\n    \tINSIDE: INSIDE,\n    \tINHERIT: INHERIT,\n    \tLEFT: LEFT,\n    \tMAX_VALUE: MAX_VALUE,\n    \tMIN_VALUE: MIN_VALUE,\n    \tNONE: NONE,\n    \tNOTE_CLICK: NOTE_CLICK,\n    \tNOTE_HOVER: NOTE_HOVER,\n    \tNOTE_LEAVE: NOTE_LEAVE,\n    \tOBJECT: OBJECT,\n    \tOUTSIDE: OUTSIDE,\n    \tRIGHT: RIGHT,\n    \tROUNDED_RECT: ROUNDED_RECT,\n    \tSTART: START,\n    \tSTRING: STRING,\n    \tTOP: TOP,\n    \tTRIANGLE: TRIANGLE,\n    \tSQUARE: SQUARE,\n    \tRECT: RECT,\n    \tVALUE: VALUE,\n    \tWHITE: WHITE,\n    \tWIDTH: WIDTH,\n    \tX: X,\n    \tY: Y,\n    \tDEFAULT_SERIES_OPACITY: DEFAULT_SERIES_OPACITY,\n    \tPOINTER: POINTER,\n    \tHORIZONTAL: HORIZONTAL,\n    \tVERTICAL: VERTICAL\n    };\n\n    function isArray(value) {\n        return Array.isArray(value);\n    }\n\n    function addClass(element, classes) {\n        var classArray = isArray(classes) ? classes : [ classes ];\n\n        for (var idx = 0; idx < classArray.length; idx++) {\n            var className = classArray[idx];\n            if (element.className.indexOf(className) === -1) {\n                element.className += \" \" + className;\n            }\n        }\n    }\n\n    var SPACE_REGEX = /\\s+/g;\n\n    function removeClass(element, className) {\n        if (element && element.className) {\n            element.className = element.className.replace(className, \"\").replace(SPACE_REGEX, \" \");\n        }\n    }\n\n    function alignPathToPixel(path) {\n        var offset = 0.5;\n        if (path.options.stroke && kendo.drawing.util.defined(path.options.stroke.width)) {\n            if (path.options.stroke.width % 2 === 0) {\n                offset = 0;\n            }\n        }\n\n        for (var i = 0; i < path.segments.length; i++) {\n            path.segments[i].anchor().round(0).translate(offset, offset);\n        }\n\n        return path;\n    }\n\n    function clockwise(angle1, angle2) {\n        // True if angle2 is clockwise of angle1\n        // assuming angles grow in clock-wise direction\n        // (as in the pie and radar charts)\n        return -angle1.x * angle2.y + angle1.y * angle2.x < 0;\n    }\n\n    function isNumber(value) {\n        return typeof value === \"number\" && !isNaN(value);\n    }\n\n    function isString(value) {\n        return typeof value === STRING;\n    }\n\n    function convertableToNumber(value) {\n        return isNumber(value) || (isString(value) && isFinite(value));\n    }\n\n    function cycleUp(index, count) {\n        return (index + 1) % count;\n    }\n\n    function cycleDown(index, count) {\n        var result = index - 1;\n\n        return result < 0 ? count - 1 : result;\n    }\n\n    function cycleIndex(index, length) {\n        if (length === 1 || (index % length) === 0) {\n            return 0;\n        }\n\n        if (index < 0) {\n            return length + (index % length);\n        } else if (index >= length) {\n            return index % length;\n        }\n\n        return index;\n    }\n\n    function isObject(value) {\n        return typeof value === \"object\";\n    }\n\n    function styleValue(value) {\n        if (isNumber(value)) {\n            return value + \"px\";\n        }\n        return value;\n    }\n\n    var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;\n\n    function isSizeField(field) {\n        return SIZE_STYLES_REGEX.test(field);\n    }\n\n    function elementStyles(element, styles) {\n        var stylesArray = isString(styles) ? [ styles ] : styles;\n\n        if (isArray(stylesArray)) {\n            var result = {};\n            var style = window.getComputedStyle(element);\n\n            for (var idx = 0; idx < stylesArray.length; idx++) {\n                var field = stylesArray[idx];\n                result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];\n            }\n\n            return result;\n        } else if (isObject(styles)) {\n            for (var field$1 in styles) {\n                element.style[field$1] = styleValue(styles[field$1]);\n            }\n        }\n    }\n\n    function getSpacing(value, defaultSpacing) {\n        if (defaultSpacing === void 0) { defaultSpacing = 0; }\n\n        var spacing = { top: 0, right: 0, bottom: 0, left: 0 };\n\n        if (typeof(value) === \"number\") {\n            spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;\n        } else {\n            spacing[TOP] = value[TOP] || defaultSpacing;\n            spacing[RIGHT] = value[RIGHT] || defaultSpacing;\n            spacing[BOTTOM] = value[BOTTOM] || defaultSpacing;\n            spacing[LEFT] = value[LEFT] || defaultSpacing;\n        }\n\n        return spacing;\n    }\n\n    var current = {\n        compile: function(template) {\n            return template;\n        }\n    };\n\n    var TemplateService = Class.extend({\n\n    });\n\n    TemplateService.register = function(userImplementation) {\n        current = userImplementation;\n    };\n\n    TemplateService.compile = function(template, options) {\n        return current.compile(template, options);\n    };\n\n    function getTemplate(options) {\n        if (options === void 0) { options = {}; }\n\n        var template;\n        if (options.template) {\n            options.template = template = TemplateService.compile(options.template);\n        } else if (isFunction(options.content)) {\n            template = options.content;\n        }\n\n        return template;\n    }\n\n    function getTemplate$1(options) {\n        if (options === void 0) { options = {}; }\n\n        var ariaTemplate;\n        if (options.ariaTemplate) {\n            options.ariaTemplate = ariaTemplate = TemplateService.compile(options.ariaTemplate);\n        } else if (isFunction(options.ariaContent)) {\n            ariaTemplate = options.ariaContent;\n        }\n\n        return ariaTemplate;\n    }\n\n    function grep(array, callback) {\n        var length = array.length;\n        var result = [];\n        for (var idx = 0; idx < length; idx++) {\n            if (callback(array[idx])) {\n                result .push(array[idx]);\n            }\n        }\n\n        return result;\n    }\n\n    function hasClasses(element, classNames) {\n        if (element.className) {\n            var names = classNames.split(\" \");\n            for (var idx = 0; idx < names.length; idx++) {\n                if (element.className.indexOf && element.className.indexOf(names[idx]) !== -1) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    // TODO: Remove and replace with Map/WeakMap.\n    var HashMap = function HashMap() {\n        this._map = new Map();\n    };\n\n    HashMap.prototype.get = function get (key) {\n        return this._map.get(key);\n    };\n\n    HashMap.prototype.set = function set (key, value) {\n        this._map.set(key, value);\n    };\n\n    function inArray(value, array) {\n        if (array) {\n            return array.indexOf(value) !== -1;\n        }\n    }\n\n    function interpolateValue(start, end, progress) {\n        return kendo.drawing.util.round(start + (end - start) * progress, COORD_PRECISION);\n    }\n\n    var TRIGGER = 'trigger';\n\n    var InstanceObserver = Class.extend({\n        init: function(observer, handlers) {\n            this.observer = observer;\n            this.handlerMap = deepExtend({}, this.handlerMap, handlers);\n        },\n\n        trigger: function(name, args) {\n            var ref = this;\n            var observer = ref.observer;\n            var handlerMap = ref.handlerMap;\n            var isDefaultPrevented;\n            if (handlerMap[name]) {\n                isDefaultPrevented = this.callObserver(handlerMap[name], args);\n            } else if (observer[TRIGGER]) {\n                isDefaultPrevented = this.callObserver(TRIGGER, name, args);\n            }\n\n            return isDefaultPrevented;\n        },\n\n        callObserver: function(fnName) {\n            var args = [], len = arguments.length - 1;\n            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n            return this.observer[fnName].apply(this.observer, args);\n        },\n\n        requiresHandlers: function(names) {\n            var this$1$1 = this;\n\n            if (this.observer.requiresHandlers) {\n                return this.observer.requiresHandlers(names);\n            }\n\n            for (var idx = 0; idx < names.length; idx++) {\n                if (this$1$1.handlerMap[names[idx]]) {\n                    return true;\n                }\n            }\n        }\n    });\n\n    function isPlainObject(value) {\n        return Object.prototype.toString.call(value) === \"[object Object]\";\n    }\n\n    function map(array, callback) {\n        var length = array.length;\n        var result = [];\n        for (var idx = 0; idx < length; idx++) {\n            var value = callback(array[idx]);\n            if (kendo.drawing.util.defined(value)) {\n                result.push(value);\n            }\n        }\n        return result;\n    }\n\n    var browser = support.browser || {};\n\n    function mousewheelDelta(e) {\n        var delta = 0;\n\n        if (e.wheelDelta) {\n            delta = -e.wheelDelta / 120;\n\n            if (browser.webkit) {\n                // Webkit browsers scale the delta by twice the device resolution.\n                // Possibly related to https://bugs.webkit.org/show_bug.cgi?id=196339\n                //\n                // Low device resolutions (e.g. zoom-out to 30%) also behave strangely.\n                delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));\n            }\n        } else if (e.detail) {\n            delta = e.detail / 3;\n        }\n\n        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\n        return delta;\n    }\n\n    var ref = kendo.drawing.util;\n    var append = ref.append;\n    var bindEvents = ref.bindEvents;\n    var defined = ref.defined;\n    var deg = ref.deg;\n    var elementOffset = ref.elementOffset;\n    var elementSize = ref.elementSize;\n    var eventCoordinates = ref.eventCoordinates;\n    var eventElement = ref.eventElement;\n    var hashKey = ref.hashKey;\n    var last = ref.last;\n    var limitValue = ref.limitValue;\n    var objectKey = ref.objectKey;\n    var rad = ref.rad;\n    var round = ref.round;\n    var unbindEvents = ref.unbindEvents;\n    var valueOrDefault = ref.valueOrDefault;\n\n    var FontLoader = Class.extend({\n\n    });\n\n    FontLoader.fetchFonts = function(options, fonts, state) {\n        if (state === void 0) { state = { depth: 0 }; }\n\n        var MAX_DEPTH = 5;\n\n        if (!options || state.depth > MAX_DEPTH || !document.fonts) {\n            return;\n        }\n\n        Object.keys(options).forEach(function(key) {\n            var value = options[key];\n            if (key === \"dataSource\" || key[0] === \"$\" || !value) {\n                return;\n            }\n\n            if (key === \"font\") {\n                fonts.push(value);\n            } else if (typeof value === \"object\") {\n                state.depth++;\n                FontLoader.fetchFonts(value, fonts, state);\n                state.depth--;\n            }\n        });\n    };\n\n    FontLoader.loadFonts = function(fonts, callback) {\n        var promises = [];\n\n        if (fonts.length > 0 && document.fonts) {\n            try {\n                promises = fonts.map(function(font) {\n                    return document.fonts.load(font);\n                });\n            } catch (e) {\n                // Silence font-loading errors\n                kendo.logToConsole(e);\n            }\n\n            Promise.all(promises).then(callback, callback);\n        } else {\n            callback();\n        }\n    };\n\n    FontLoader.preloadFonts = function(options, callback) {\n        var fonts = [];\n        FontLoader.fetchFonts(options, fonts);\n\n        FontLoader.loadFonts(fonts, callback);\n    };\n\n    function setDefaultOptions(type, options) {\n        var proto = type.prototype;\n        if (proto.options) {\n            proto.options = deepExtend({}, proto.options, options);\n        } else {\n            proto.options = options;\n        }\n    }\n\n    var KICON = 'k-icon';\n    var KI_PREFFIX = 'k-i-';\n    var KSVGICON = 'k-svg-icon';\n    var KSVG_PREFFIX = 'k-svg-i-';\n\n    var HTMLBaseIcon = Class.extend({\n        init: function(element, options) {\n            this.element = element;\n            this.options = deepExtend({}, this.options, options);\n\n            this.wrapper();\n        },\n\n        wrapper: function() {\n            this.addClasses();\n        },\n\n        addClasses: function() {\n        },\n\n        html: function() {\n            return this.element.outerHTML;\n        }\n    });\n\n    setDefaultOptions(HTMLBaseIcon, {\n        name: '',\n        size: 'none',\n        themeColor: 'none',\n        flip: 'default',\n        iconClass: '',\n        stylingOptions: [ 'size', 'themeColor', 'fill' ]\n    });\n\n    var HTMLFontIcon = HTMLBaseIcon.extend({\n        init: function(element, options) {\n            HTMLBaseIcon.fn.init.call(this, element, options);\n        },\n\n        wrapper: function() {\n            // Find if there is an existing k-i- class appended to the element.\n            var currentIconClass = this.element.className.split(\" \").find(function (x) { return x.startsWith(KI_PREFFIX); });\n            var className = this.options.icon ? (\"\" + (this.options.icon.startsWith(KI_PREFFIX) ? \"\" : KI_PREFFIX) + (this.options.icon)) : \"\";\n\n            this._className = className;\n\n            addClass(this.element, KICON);\n            removeClass(this.element, currentIconClass); // Remove any existing icons.\n            addClass(this.element, className);\n            addClass(this.element, this.options.iconClass || '');\n\n            HTMLBaseIcon.fn.wrapper.call(this);\n        }\n    });\n\n    setDefaultOptions(HTMLFontIcon, {\n        name: 'HTMLFontIcon',\n        icon: null\n    });\n\n    var HTMLSvgIcon = HTMLBaseIcon.extend({\n        init: function(element, options) {\n            // Ensure that the inner contents of the wrapping span element are always removed for re-rendering purposes.\n            element.innerHTML = \"\";\n\n            HTMLBaseIcon.fn.init.call(this, element, options);\n        },\n\n        wrapper: function() {\n            var icon = this.options.icon;\n            var iconClass = this.options.iconClass;\n            var currentIconClass = this.element.className.split(\" \").find(function (x) { return x.startsWith(KSVG_PREFFIX); });\n\n            if (!icon && iconClass) {\n                // match k-i-(some-icon-name)\n                var regex = /k-i-(\\w+(?:-\\w+)*)/;\n                var iconNameMatch = iconClass.match(regex);\n                if (iconNameMatch) {\n                    icon = iconNameMatch[1];\n                    iconClass = iconClass.replace(iconNameMatch[0], \"\");\n                }\n            }\n\n            if (isString(icon)) {\n                icon = icon.replace(\"k-i-\", \"\").replace(/-./g, function (x) { return x[1].toUpperCase(); });\n                icon = this.options.svgIcons[icon] || this.options.svgIcons[(icon + \"Icon\")];\n            }\n\n            var className = icon && icon.name ? (\"\" + KSVG_PREFFIX + (icon.name)) : \"\";\n            this._className = className;\n\n            addClass(this.element, KSVGICON);\n            removeClass(this.element, currentIconClass);\n            addClass(this.element, className);\n            addClass(this.element, iconClass || \"\");\n            this.element.setAttribute(\"aria-hidden\", \"true\");\n\n            if (icon && isPlainObject(icon)) {\n                var svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n                svgElement.setAttribute(\"viewBox\", icon.viewBox || \"\");\n                svgElement.setAttribute(\"focusable\", \"false\");\n                svgElement.innerHTML = icon.content || \"\";\n\n                this.element.appendChild(svgElement);\n            }\n\n            HTMLBaseIcon.fn.wrapper.call(this);\n        }\n    });\n\n    setDefaultOptions(HTMLSvgIcon, {\n        name: 'HTMLSvgIcon',\n        icon: null,\n        svgIcons: {}\n    });\n\n    var ICON_TYPES = {\n        'svg': HTMLSvgIcon,\n        'font': HTMLFontIcon\n    };\n\n    function renderIcon(iconElement, iconOptions) {\n        var element = iconElement;\n        var options = iconOptions;\n\n        if (!element\n            || (isObject(element) && !(element instanceof HTMLElement))\n            || isString(element)) {\n            options = element;\n            element = document.createElement(\"span\");\n        }\n\n        if (isString(options)) {\n            options = {\n                icon: options\n            };\n        }\n\n        if (!options.type) {\n            options.type = 'svg';\n        }\n\n        if (!ICON_TYPES[options.type]) {\n            return null;\n        }\n\n        return (new ICON_TYPES[options.type](element, options).html());\n    }\n\n    function sparseArrayLimits(arr) {\n        var min = MAX_VALUE;\n        var max = MIN_VALUE;\n\n        for (var idx = 0, length = arr.length; idx < length; idx++) {\n            var value = arr[idx];\n            if (value !== null && isFinite(value)) {\n                min = Math.min(min, value);\n                max = Math.max(max, value);\n            }\n        }\n\n        return {\n            min: min === MAX_VALUE ? undefined : min,\n            max: max === MIN_VALUE ? undefined : max\n        };\n    }\n\n    function find(array, predicate) {\n        for (var i = 0; i < array.length; i++) {\n            var item = array[i];\n            if (predicate(item, i, array)) {\n                return item;\n            }\n        }\n    }\n\n    var Matrix = geometry.Matrix;\n    var matrixRegexp = /matrix\\((.*)\\)/;\n\n    function parseMatrix(matrixString) {\n        var match = matrixString.match(matrixRegexp);\n        if (match === null || match.length !== 2) {\n            return Matrix.unit();\n        }\n\n        var members = match[1].split(',').map(function (x) { return parseFloat(x); });\n        return new (Function.prototype.bind.apply( Matrix, [ null ].concat( members) ));\n    }\n\n    function transformMatrix(element) {\n        var transform = getComputedStyle(element).transform;\n\n        if (transform === 'none') {\n            return Matrix.unit();\n        }\n\n        return parseMatrix(transform);\n    }\n\n    function elementScale(element) {\n        if (!element) {\n            return Matrix.unit();\n        }\n\n        var matrix = transformMatrix(element);\n        var parent = element.parentElement;\n        while (parent) {\n            var parentMatrix = transformMatrix(parent);\n            matrix = matrix.multiplyCopy(parentMatrix);\n            parent = parent.parentElement;\n        }\n\n        matrix.b = matrix.c = matrix.e = matrix.f = 0;\n        return matrix;\n    }\n\n    function autoTextColor(color) {\n        var isDark = new kendo.Color(color).isDark();\n        if (isDark) {\n            return WHITE;\n        }\n\n        return BLACK;\n    }\n\n    var DELETED = {};\n\n    var LegacySet = Class.extend({\n        init: function(values) {\n            var this$1$1 = this;\n\n            this._index = {};\n            this._values = values ? values.slice(0) : [];\n\n            for (var i = 0; i < this._values.length; i++) {\n                this$1$1._index[this$1$1._values[i]] = i;\n            }\n        },\n\n        values: function() {\n            return this._values.filter(function (item) { return item !== DELETED; });\n        },\n\n        has: function(value) {\n            return this._index[value] !== undefined;\n        },\n\n        add: function(value) {\n            if (!this.has(value)) {\n                this._index[value] = this._values.length;\n                this._values.push(value);\n            }\n        },\n\n        delete: function(value) {\n            var index = this._index[value];\n            if (index !== undefined) {\n                this._values[index] = DELETED;\n                delete this._index[value];\n            }\n        },\n\n        clear: function() {\n            this._index = {};\n            this._values = [];\n        }\n    });\n\n    if (Object.defineProperties) {\n        Object.defineProperties(LegacySet.fn, {\n            size: {\n                get: function() {\n                    return this._values.length;\n                }\n            }\n        });\n    }\n\n    var SetWrapper = Class.extend({\n        init: function(values) {\n            this._set = new Set(values);\n        },\n\n        values: function() {\n            return Array.from(this._set);\n        },\n\n        has: function(value) {\n            return this._set.has(value);\n        },\n\n        add: function(value) {\n            this._set.add(value);\n        },\n\n        delete: function(value) {\n            this._set.delete(value);\n        },\n\n        clear: function() {\n            this._set.clear();\n        }\n    });\n\n    if (Object.defineProperties) {\n        Object.defineProperties(SetWrapper.fn, {\n            size: {\n                get: function() {\n                    return this._set.size;\n                }\n            }\n        });\n    }\n\n    // TODO: Drop LegacySet when removing support for IE10\n    var supportsSet = function () {\n        var supported = false;\n\n        if (typeof Set === 'function') {\n            var set = new Set([1]);\n            supported = set.has(1);\n        }\n\n        return supported;\n    };\n\n    function createHashSet(values) {\n        if (supportsSet()) {\n            return new SetWrapper(values);\n        }\n\n        return new LegacySet(values);\n    }\n\n    function defaultErrorHandler(error) {\n        throw error;\n    }\n\n    var keys = {\n        INSERT: 45,\n        DELETE: 46,\n        BACKSPACE: 8,\n        TAB: 9,\n        ENTER: 13,\n        ESC: 27,\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        DOWN: 40,\n        END: 35,\n        HOME: 36,\n        SPACEBAR: 32,\n        PAGEUP: 33,\n        PAGEDOWN: 34,\n        F2: 113,\n        F10: 121,\n        F12: 123,\n        NUMPAD_PLUS: 107,\n        NUMPAD_MINUS: 109,\n        NUMPAD_DOT: 110\n    };\n\n    function hasOwnProperty(obj, property) {\n        return Object.prototype.hasOwnProperty.call(obj, property);\n    }\n\n    // Based on the implementation from kendo-spreadsheet-common/src/calc.js\n    var Matrix$1 = Class.extend({\n        init: function() {\n            this.height = 0;\n            this.width = 0;\n            this.data = [];\n        },\n\n        clone: function() {\n            var m = new Matrix$1();\n            m.height = this.height;\n            m.width = this.width;\n            m.data = this.data.map(function (row) { return row.slice(); });\n            return m;\n        },\n\n        get: function(row, col) {\n            var line = this.data[row];\n            var val = line ? line[col] : null;\n            return val;\n        },\n\n        set: function(row, col, data) {\n            var line = this.data[row];\n            if (line == null) {\n                line = this.data[row] = [];\n            }\n            line[col] = data;\n            if (row >= this.height) {\n                this.height = row + 1;\n            }\n            if (col >= this.width) {\n                this.width = col + 1;\n            }\n        },\n\n        each: function(f, includeEmpty) {\n            var this$1$1 = this;\n\n            for (var row = 0; row < this.height; ++row) {\n                for (var col = 0; col < this.width; ++col) {\n                    var val = this$1$1.get(row, col);\n                    if (includeEmpty || val != null) {\n                        val = f(val, row, col);\n                        if (val !== undefined) {\n                            return val;\n                        }\n                    }\n                }\n            }\n        },\n\n        map: function(f, includeEmpty) {\n            var m = new Matrix$1();\n            this.each(function(el, row, col) {\n                m.set(row, col, f(el, row, col));\n            }, includeEmpty);\n            return m;\n        },\n\n        transpose: function() {\n            var m = new Matrix$1();\n            this.each(function(el, row, col) {\n                m.set(col, row, el);\n            });\n            return m;\n        },\n\n        unit: function(n) {\n            this.width = this.height = n;\n            var a = this.data = new Array(n);\n            for (var i = n; --i >= 0;) {\n                var row = a[i] = new Array(n);\n                for (var j = n; --j >= 0;) {\n                    row[j] = i === j ? 1 : 0;\n                }\n            }\n            return this;\n        },\n\n        multiply: function(b) {\n            var a = this;\n            var m = new Matrix$1();\n            for (var row = 0; row < a.height; ++row) {\n                for (var col = 0; col < b.width; ++col) {\n                    var s = 0;\n                    for (var i = 0; i < a.width; ++i) {\n                        var va = a.get(row, i);\n                        var vb = b.get(i, col);\n                        if (typeof va === \"number\" && typeof vb === \"number\") {\n                            s += va * vb;\n                        }\n                    }\n                    m.set(row, col, s);\n                }\n            }\n            return m;\n        },\n\n        inverse: function() {\n            var n = this.width;\n            var m = this.augment(new Matrix$1().unit(n));\n            var a = m.data;\n\n            // Gaussian elimination\n            // https://en.wikipedia.org/wiki/Gaussian_elimination#Finding_the_inverse_of_a_matrix\n\n            // 1. Get zeros below main diagonal\n            var loop = function ( k ) {\n                var imax = argmax(k, n, function(i) { return a[i][k]; });\n                if (!a[imax][k]) {\n                    return { v: null }; // singular matrix\n                }\n                if (k !== imax) {\n                    var tmp = a[k];\n                    a[k] = a[imax];\n                    a[imax] = tmp;\n                }\n                for (var i = k + 1; i < n; ++i) {\n                    for (var j = k + 1; j < 2 * n; ++j) {\n                        a[i][j] -= a[k][j] * a[i][k] / a[k][k];\n                    }\n                    a[i][k] = 0;\n                }\n            };\n\n            for (var k = 0; k < n; ++k) {\n                var returned = loop( k );\n\n                if ( returned ) return returned.v;\n            }\n\n            // 2. Get 1-s on main diagonal, dividing by pivot\n            for (var i$1 = 0; i$1 < n; ++i$1) {\n                for (var f = a[i$1][i$1], j$1 = 0; j$1 < 2 * n; ++j$1) {\n                    a[i$1][j$1] /= f;\n                }\n            }\n\n            // 3. Get zeros above main diagonal.  Actually, we only care to compute the right side\n            // here (that will be the inverse), so in the inner loop below we go while j >= n,\n            // instead of j >= k.\n            for (var k$1 = n; --k$1 >= 0;) {\n                for (var i$2 = k$1; --i$2 >= 0;) {\n                    if (a[i$2][k$1]) {\n                        for (var j$2 = 2 * n; --j$2 >= n;) {\n                            a[i$2][j$2] -= a[k$1][j$2] * a[i$2][k$1];\n                        }\n                    }\n                }\n            }\n\n            return m.slice(0, n, n, n);\n        },\n\n        augment: function(m) {\n            var ret = this.clone();\n            var n = ret.width;\n            m.each(function(val, row, col) {\n                ret.set(row, col + n, val);\n            });\n            return ret;\n        },\n\n        slice: function(row, col, height, width) {\n            var this$1$1 = this;\n\n            var m = new Matrix$1();\n            for (var i = 0; i < height; ++i) {\n                for (var j = 0; j < width; ++j) {\n                    m.set(i, j, this$1$1.get(row + i, col + j));\n                }\n            }\n            return m;\n        }\n    });\n\n    function argmax(start, end, f) {\n        var max = f(start), pos = start;\n        for (var i = start + 1; i < end; i++) {\n            var v = f(start);\n            if (v > max) {\n                max = v;\n                pos = start;\n            }\n        }\n        return pos;\n    }\n\n    function autoMajorUnit(min, max) {\n        var diff = round(max - min, DEFAULT_PRECISION - 1);\n\n        if (diff === 0) {\n            if (max === 0) {\n                return 0.1;\n            }\n\n            diff = Math.abs(max);\n        }\n\n        var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));\n        var relativeValue = round((diff / scale), DEFAULT_PRECISION);\n        var scaleMultiplier = 1;\n\n        if (relativeValue < 1.904762) {\n            scaleMultiplier = 0.2;\n        } else if (relativeValue < 4.761904) {\n            scaleMultiplier = 0.5;\n        } else if (relativeValue < 9.523809) {\n            scaleMultiplier = 1;\n        } else {\n            scaleMultiplier = 2;\n        }\n\n        return round(scale * scaleMultiplier, DEFAULT_PRECISION);\n    }\n\n    var Point = Class.extend({\n        init: function(x, y) {\n\n            this.x = x || 0;\n            this.y = y || 0;\n        },\n\n        clone: function() {\n            return new Point(this.x, this.y);\n        },\n\n        equals: function(point) {\n            return point && this.x === point.x && this.y === point.y;\n        },\n\n        rotate: function(center, degrees) {\n            var theta = rad(degrees);\n            var cosT = Math.cos(theta);\n            var sinT = Math.sin(theta);\n            var cx = center.x;\n            var cy = center.y;\n            var ref = this;\n            var x = ref.x;\n            var y = ref.y;\n\n            this.x = round(\n                cx + (x - cx) * cosT + (y - cy) * sinT,\n                COORD_PRECISION\n            );\n\n            this.y = round(\n                cy + (y - cy) * cosT - (x - cx) * sinT,\n                COORD_PRECISION\n            );\n\n            return this;\n        },\n\n        multiply: function(a) {\n\n            this.x *= a;\n            this.y *= a;\n\n            return this;\n        },\n\n        distanceTo: function(point) {\n            var dx = this.x - point.x;\n            var dy = this.y - point.y;\n\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n    });\n\n    Point.onCircle = function(center, angle, radius) {\n        var radians = rad(angle);\n\n        return new Point(\n            center.x - radius * Math.cos(radians),\n            center.y - radius * Math.sin(radians)\n        );\n    };\n\n    var Box = Class.extend({\n        init: function(x1, y1, x2, y2) {\n\n            this.x1 = x1 || 0;\n            this.y1 = y1 || 0;\n            this.x2 = x2 || 0;\n            this.y2 = y2 || 0;\n        },\n\n        equals: function(box) {\n            return this.x1 === box.x1 && this.x2 === box.x2 &&\n                this.y1 === box.y1 && this.y2 === box.y2;\n        },\n\n        width: function() {\n            return this.x2 - this.x1;\n        },\n\n        height: function() {\n            return this.y2 - this.y1;\n        },\n\n        translate: function(dx, dy) {\n            this.x1 += dx;\n            this.x2 += dx;\n            this.y1 += dy;\n            this.y2 += dy;\n\n            return this;\n        },\n\n        move: function(x, y) {\n            var height = this.height();\n            var width = this.width();\n\n            if (defined(x)) {\n                this.x1 = x;\n                this.x2 = this.x1 + width;\n            }\n\n            if (defined(y)) {\n                this.y1 = y;\n                this.y2 = this.y1 + height;\n            }\n\n            return this;\n        },\n\n        wrap: function(targetBox) {\n            this.x1 = Math.min(this.x1, targetBox.x1);\n            this.y1 = Math.min(this.y1, targetBox.y1);\n            this.x2 = Math.max(this.x2, targetBox.x2);\n            this.y2 = Math.max(this.y2, targetBox.y2);\n\n            return this;\n        },\n\n        wrapPoint: function(point) {\n            var arrayPoint = isArray(point);\n            var x = arrayPoint ? point[0] : point.x;\n            var y = arrayPoint ? point[1] : point.y;\n            this.wrap(new Box(x, y, x, y));\n\n            return this;\n        },\n\n        snapTo: function(targetBox, axis) {\n\n            if (axis === X || !axis) {\n                this.x1 = targetBox.x1;\n                this.x2 = targetBox.x2;\n            }\n\n            if (axis === Y || !axis) {\n                this.y1 = targetBox.y1;\n                this.y2 = targetBox.y2;\n            }\n\n            return this;\n        },\n\n        alignTo: function(targetBox, anchor) {\n            var height = this.height();\n            var width = this.width();\n            var axis = anchor === TOP || anchor === BOTTOM ? Y : X;\n            var offset = axis === Y ? height : width;\n\n            if (anchor === CENTER) {\n                var targetCenter = targetBox.center();\n                var center = this.center();\n\n                this.x1 += targetCenter.x - center.x;\n                this.y1 += targetCenter.y - center.y;\n            } else if (anchor === TOP || anchor === LEFT) {\n                this[axis + 1] = targetBox[axis + 1] - offset;\n            } else {\n                this[axis + 1] = targetBox[axis + 2];\n            }\n\n            this.x2 = this.x1 + width;\n            this.y2 = this.y1 + height;\n\n            return this;\n        },\n\n        shrink: function(dw, dh) {\n\n            this.x2 -= dw;\n            this.y2 -= dh;\n\n            return this;\n        },\n\n        expand: function(dw, dh) {\n            this.shrink(-dw, -dh);\n            return this;\n        },\n\n        pad: function(padding) {\n            var spacing = getSpacing(padding);\n\n            this.x1 -= spacing.left;\n            this.x2 += spacing.right;\n            this.y1 -= spacing.top;\n            this.y2 += spacing.bottom;\n\n            return this;\n        },\n\n        unpad: function(padding) {\n            var spacing = getSpacing(padding);\n\n            spacing.left = -spacing.left;\n            spacing.top = -spacing.top;\n            spacing.right = -spacing.right;\n            spacing.bottom = -spacing.bottom;\n\n            return this.pad(spacing);\n        },\n\n        clone: function() {\n            return new Box(this.x1, this.y1, this.x2, this.y2);\n        },\n\n        center: function() {\n            return new Point(\n                this.x1 + this.width() / 2,\n                this.y1 + this.height() / 2\n            );\n        },\n\n        containsPoint: function(point) {\n\n            return point.x >= this.x1 && point.x <= this.x2 &&\n                   point.y >= this.y1 && point.y <= this.y2;\n        },\n\n        points: function() {\n            return [\n                new Point(this.x1, this.y1),\n                new Point(this.x2, this.y1),\n                new Point(this.x2, this.y2),\n                new Point(this.x1, this.y2)\n            ];\n        },\n\n        getHash: function() {\n            return [ this.x1, this.y1, this.x2, this.y2 ].join(\",\");\n        },\n\n        overlaps: function(box) {\n            return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\n        },\n\n        rotate: function(rotation) {\n            var width = this.width();\n            var height = this.height();\n            var ref = this.center();\n            var cx = ref.x;\n            var cy = ref.y;\n\n            var r1 = rotatePoint(0, 0, cx, cy, rotation);\n            var r2 = rotatePoint(width, 0, cx, cy, rotation);\n            var r3 = rotatePoint(width, height, cx, cy, rotation);\n            var r4 = rotatePoint(0, height, cx, cy, rotation);\n\n            width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\n            height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\n\n            this.x2 = this.x1 + width;\n            this.y2 = this.y1 + height;\n\n            return this;\n        },\n\n        toRect: function() {\n            return new Rect([ this.x1, this.y1 ], [ this.width(), this.height() ]);\n        },\n\n        hasSize: function() {\n            return this.width() !== 0 && this.height() !== 0;\n        },\n\n        align: function(targetBox, axis, alignment) {\n            var c1 = axis + 1;\n            var c2 = axis + 2;\n            var sizeFunc = axis === X ? WIDTH : HEIGHT;\n            var size = this[sizeFunc]();\n\n            if (inArray(alignment, [ LEFT, TOP ])) {\n                this[c1] = targetBox[c1];\n                this[c2] = this[c1] + size;\n            } else if (inArray(alignment, [ RIGHT, BOTTOM ])) {\n                this[c2] = targetBox[c2];\n                this[c1] = this[c2] - size;\n            } else if (alignment === CENTER) {\n                this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\n                this[c2] = this[c1] + size;\n            }\n        }\n    });\n\n    function rotatePoint(x, y, cx, cy, angle) {\n        var theta = rad(angle);\n\n        return new Point(\n            cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),\n            cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)\n        );\n    }\n\n    var Ring = Class.extend({\n        init: function(center, innerRadius, radius, startAngle, angle) {\n\n            this.center = center;\n            this.innerRadius = innerRadius;\n            this.radius = radius;\n            this.startAngle = startAngle;\n            this.angle = angle;\n        },\n\n        clone: function() {\n            return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n        },\n\n        middle: function() {\n            return this.startAngle + this.angle / 2;\n        },\n\n        setRadius: function(newRadius, innerRadius) {\n            if (innerRadius) {\n                this.innerRadius = newRadius;\n            } else {\n                this.radius = newRadius;\n            }\n\n            return this;\n        },\n\n        point: function(angle, innerRadius) {\n            var radianAngle = rad(angle);\n            var ax = Math.cos(radianAngle);\n            var ay = Math.sin(radianAngle);\n            var radius = innerRadius ? this.innerRadius : this.radius;\n            var x = round(this.center.x - (ax * radius), COORD_PRECISION);\n            var y = round(this.center.y - (ay * radius), COORD_PRECISION);\n\n            return new Point(x, y);\n        },\n\n        adjacentBox: function(distance, width, height) {\n            var sector = this.clone().expand(distance);\n            var midAndle = sector.middle();\n            var midPoint = sector.point(midAndle);\n            var hw = width / 2;\n            var hh = height / 2;\n            var sa = Math.sin(rad(midAndle));\n            var ca = Math.cos(rad(midAndle));\n            var x = midPoint.x - hw;\n            var y = midPoint.y - hh;\n\n            if (Math.abs(sa) < 0.9) {\n                x += hw * -ca / Math.abs(ca);\n            }\n\n            if (Math.abs(ca) < 0.9) {\n                y += hh * -sa / Math.abs(sa);\n            }\n\n            return new Box(x, y, x + width, y + height);\n        },\n\n        containsPoint: function(p) {\n            var center = this.center;\n            var innerRadius = this.innerRadius;\n            var radius = this.radius;\n            var startAngle = this.startAngle;\n            var endAngle = this.startAngle + this.angle;\n            var dx = p.x - center.x;\n            var dy = p.y - center.y;\n            var vector = new Point(dx, dy);\n            var startPoint = this.point(startAngle);\n            var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n            var endPoint = this.point(endAngle);\n            var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n            var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n\n            return (startVector.equals(vector) || clockwise(startVector, vector)) &&\n                   !clockwise(endVector, vector) &&\n                   dist >= innerRadius * innerRadius && dist <= radius * radius;\n        },\n\n        getBBox: function() {\n            var this$1$1 = this;\n\n            var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n            var startAngle = round(this.startAngle % 360);\n            var endAngle = round((startAngle + this.angle) % 360);\n            var innerRadius = this.innerRadius;\n            var allAngles = [ 0, 90, 180, 270, startAngle, endAngle ].sort(numericComparer);\n            var startAngleIndex = allAngles.indexOf(startAngle);\n            var endAngleIndex = allAngles.indexOf(endAngle);\n            var angles;\n\n            if (startAngle === endAngle) {\n                angles = allAngles;\n            } else {\n                if (startAngleIndex < endAngleIndex) {\n                    angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n                } else {\n                    angles = [].concat(\n                        allAngles.slice(0, endAngleIndex + 1),\n                        allAngles.slice(startAngleIndex, allAngles.length)\n                    );\n                }\n            }\n\n            for (var i = 0; i < angles.length; i++) {\n                var point = this$1$1.point(angles[i]);\n                box.wrapPoint(point);\n                box.wrapPoint(point, innerRadius);\n            }\n\n            if (!innerRadius) {\n                box.wrapPoint(this.center);\n            }\n\n            return box;\n        },\n\n        expand: function(value) {\n            this.radius += value;\n            return this;\n        }\n    });\n\n    function numericComparer(a, b) {\n        return a - b;\n    }\n\n    var Sector = Ring.extend({\n        init: function(center, radius, startAngle, angle) {\n            Ring.fn.init.call(this, center, 0, radius, startAngle, angle);\n        },\n\n        expand: function(value) {\n            return Ring.fn.expand.call(this, value);\n        },\n\n        clone: function() {\n            return new Sector(this.center, this.radius, this.startAngle, this.angle);\n        },\n\n        setRadius: function(newRadius) {\n            this.radius = newRadius;\n\n            return this;\n        }\n    });\n\n    var DIRECTION_ANGLE = 0.001; //any value that will make the endAngle bigger than the start angle will work here.\n\n    var ShapeBuilder = Class.extend({\n        createRing: function(sector, options) {\n            var startAngle = sector.startAngle + 180;\n            var endAngle = sector.angle + startAngle;\n\n            //required in order to avoid reversing the arc direction in cases like 0.000000000000001 + 100 === 100\n            if (sector.angle === 0 || sector.angle > 0 && startAngle === endAngle) {\n                endAngle += DIRECTION_ANGLE;\n            }\n\n            var center = new geometry.Point(sector.center.x, sector.center.y);\n            var radius = Math.max(sector.radius, 0);\n            var innerRadius = Math.max(sector.innerRadius, 0);\n            var arc = new geometry.Arc(center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radius,\n                radiusY: radius\n            });\n            var path = Path.fromArc(arc, options).close();\n\n            if (innerRadius) {\n                arc.radiusX = arc.radiusY = innerRadius;\n                var innerEnd = arc.pointAt(endAngle);\n                path.lineTo(innerEnd.x, innerEnd.y);\n                path.arc(endAngle, startAngle, innerRadius, innerRadius, true);\n            } else {\n                path.lineTo(center.x, center.y);\n            }\n\n            return path;\n        }\n    });\n\n    ShapeBuilder.current = new ShapeBuilder();\n\n    var ChartElement = Class.extend({\n        init: function(options) {\n\n            this.children = [];\n\n            this.options = deepExtend({}, this.options, this.initUserOptions(options));\n        },\n\n        initUserOptions: function(options) {\n            return options;\n        },\n\n        reflow: function(targetBox) {\n            var children = this.children;\n            var box;\n\n            for (var i = 0; i < children.length; i++) {\n                var currentChild = children[i];\n                currentChild.reflow(targetBox);\n\n                box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\n            }\n\n            this.box = box || targetBox;\n        },\n\n        destroy: function() {\n            var children = this.children;\n\n            if (this.animation) {\n                this.animation.destroy();\n            }\n\n            for (var i = 0; i < children.length; i++) {\n                children[i].destroy();\n            }\n        },\n\n        getRoot: function() {\n            var parent = this.parent;\n\n            return parent ? parent.getRoot() : null;\n        },\n\n        getSender: function() {\n            var service = this.getService();\n            if (service) {\n                return service.sender;\n            }\n        },\n\n        getService: function() {\n            var element = this;\n            while (element) {\n                if (element.chartService) {\n                    return element.chartService;\n                }\n                element = element.parent;\n            }\n        },\n\n        translateChildren: function(dx, dy) {\n            var children = this.children;\n            var childrenCount = children.length;\n\n            for (var i = 0; i < childrenCount; i++) {\n                children[i].box.translate(dx, dy);\n            }\n        },\n\n        append: function() {\n            var arguments$1 = arguments;\n            var this$1$1 = this;\n\n            for (var i = 0; i < arguments.length; i++) {\n                var item = arguments$1[i];\n                this$1$1.children.push(item);\n                item.parent = this$1$1;\n            }\n        },\n\n        renderVisual: function() {\n            if (this.options.visible === false) {\n                return;\n            }\n\n            this.createVisual();\n\n            this.addVisual();\n\n            this.renderChildren();\n\n            this.createAnimation();\n            this.renderComplete();\n        },\n\n        addVisual: function() {\n            if (this.visual) {\n                this.visual.chartElement = this;\n\n                if (this.parent) {\n                    this.parent.appendVisual(this.visual);\n                }\n            }\n        },\n\n        renderChildren: function() {\n            var children = this.children;\n            var length = children.length;\n            for (var i = 0; i < length; i++) {\n                children[i].renderVisual();\n            }\n        },\n\n        createVisual: function() {\n            this.visual = new Group({\n                zIndex: this.options.zIndex,\n                visible: valueOrDefault(this.options.visible, true)\n            });\n        },\n\n        createAnimation: function() {\n            if (this.visual && this.options.animation) {\n                this.animation = drawing.Animation.create(\n                    this.visual, this.options.animation\n                );\n            }\n        },\n\n        appendVisual: function(childVisual) {\n            if (!childVisual.chartElement) {\n                childVisual.chartElement = this;\n            }\n\n            if (childVisual.options.noclip) {\n                this.clipRoot().visual.append(childVisual);\n            } else if (defined(childVisual.options.zIndex)) {\n                this.stackRoot().stackVisual(childVisual);\n            } else if (this.isStackRoot) {\n                this.stackVisual(childVisual);\n            } else if (this.visual) {\n                this.visual.append(childVisual);\n            } else {\n                // Allow chart elements without visuals to\n                // pass through child visuals\n                this.parent.appendVisual(childVisual);\n            }\n        },\n\n        clipRoot: function() {\n            if (this.parent) {\n                return this.parent.clipRoot();\n            }\n\n            return this;\n        },\n\n        stackRoot: function() {\n            if (this.parent) {\n                return this.parent.stackRoot();\n            }\n\n            return this;\n        },\n\n        stackVisual: function(childVisual) {\n            var zIndex = childVisual.options.zIndex || 0;\n            var visuals = this.visual.children;\n            var length = visuals.length;\n            var pos;\n\n            for (pos = 0; pos < length; pos++) {\n                var sibling = visuals[pos];\n                var here = valueOrDefault(sibling.options.zIndex, 0);\n                if (here > zIndex) {\n                    break;\n                }\n            }\n\n            this.visual.insert(pos, childVisual);\n        },\n\n        traverse: function(callback) {\n            var children = this.children;\n            var length = children.length;\n\n            for (var i = 0; i < length; i++) {\n                var child = children[i];\n\n                callback(child);\n                if (child.traverse) {\n                    child.traverse(callback);\n                }\n            }\n        },\n\n        closest: function(match) {\n            var element = this;\n            var matched = false;\n\n            while (element && !matched) {\n                matched = match(element);\n\n                if (!matched) {\n                    element = element.parent;\n                }\n            }\n\n            if (matched) {\n                return element;\n            }\n        },\n\n        renderComplete: function() {},\n\n        hasHighlight: function() {\n            var options = (this.options || {}).highlight;\n            return !(!this.createHighlight || (options && options.visible === false) || this.visible === false);\n        },\n\n        toggleHighlight: function(show, opacity) {\n            var this$1$1 = this;\n\n            var options = (this.options || {}).highlight || {};\n            var customVisual = options.visual;\n            var highlight = this._highlight;\n\n            if (!highlight) {\n                var highlightOptions = {\n                    fill: {\n                        color: WHITE,\n                        opacity: opacity || 0.2\n                    },\n                    stroke: {\n                        color: WHITE,\n                        width: 1,\n                        opacity: opacity || 0.2\n                    }\n                };\n\n                if (customVisual) {\n                    highlight = this._highlight = customVisual(\n                        $.extend(this.highlightVisualArgs(), {\n                            createVisual: function () { return this$1$1.createHighlight(highlightOptions); },\n                            sender: this.getSender(),\n                            series: this.series,\n                            dataItem: this.dataItem,\n                            category: this.category,\n                            value: this.value,\n                            percentage: this.percentage,\n                            runningTotal: this.runningTotal,\n                            total: this.total\n                        })\n                    );\n\n                    if (!highlight) {\n                        return;\n                    }\n                } else {\n                    highlight = this._highlight = this.createHighlight(highlightOptions);\n                }\n\n                if (!defined(highlight.options.zIndex)) {\n                    highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\n                }\n\n                this.appendVisual(highlight);\n            }\n\n            highlight.visible(show);\n        },\n\n        toggleFocusHighlight: function(show) {\n            var options = ((this.options || {}).accessibility || {}).highlight || {};\n            var focusHighlight = this._focusHighlight;\n\n            if (!show && !focusHighlight) {\n                return;\n            }\n\n            if (!focusHighlight) {\n                var rootBackground = this.getRoot().options.background;\n                var highlightColor = autoTextColor(rootBackground);\n                var focusHighlightOptions = {\n                    fill: {\n                        opacity: options.opacity,\n                        color: options.color\n                    },\n                    stroke: $.extend({}, {color: highlightColor}, options.border),\n                    zIndex: options.zIndex\n                };\n\n                focusHighlight = this._focusHighlight = this.createFocusHighlight(focusHighlightOptions);\n\n                this.appendVisual(focusHighlight);\n            }\n\n            focusHighlight.visible(show);\n        },\n\n        createGradientOverlay: function(element, options, gradientOptions) {\n            var overlay = new Path($.extend({\n                stroke: {\n                    color: \"none\"\n                },\n                fill: this.createGradient(gradientOptions),\n                closed: element.options.closed\n            }, options));\n\n            overlay.segments.elements(element.segments.elements());\n\n            return overlay;\n        },\n\n        createGradient: function(options) {\n            if (this.parent) {\n                return this.parent.createGradient(options);\n            }\n        },\n\n        supportsPointInactiveOpacity: function() {\n            return true;\n        }\n    });\n\n    ChartElement.prototype.options = { };\n\n    var BoxElement = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.options.margin = getSpacing(this.options.margin);\n            this.options.padding = getSpacing(this.options.padding);\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var width = options.width;\n            var height = options.height;\n            var shrinkToFit = options.shrinkToFit;\n            var hasSetSize = width && height;\n            var margin = options.margin;\n            var padding = options.padding;\n            var borderWidth = options.border.width;\n            var box;\n\n            var reflowPaddingBox = function () {\n                this$1$1.align(targetBox, X, options.align);\n                this$1$1.align(targetBox, Y, options.vAlign);\n                this$1$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\n            };\n\n            var contentBox = targetBox.clone();\n            if (hasSetSize) {\n                contentBox.x2 = contentBox.x1 + width;\n                contentBox.y2 = contentBox.y1 + height;\n            }\n\n            if (shrinkToFit) {\n                contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\n            }\n\n            ChartElement.fn.reflow.call(this, contentBox);\n\n            if (hasSetSize) {\n                box = this.box = new Box(0, 0, width, height);\n            } else {\n                box = this.box;\n            }\n\n            if (shrinkToFit && hasSetSize) {\n                reflowPaddingBox();\n                contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\n            } else {\n                contentBox = this.contentBox = box.clone();\n                box.pad(padding).pad(borderWidth).pad(margin);\n                reflowPaddingBox();\n            }\n\n            this.translateChildren(\n                box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,\n                box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top\n            );\n\n            var children = this.children;\n            for (var i = 0; i < children.length; i++) {\n                var item = children[i];\n                item.reflow(item.box);\n            }\n        },\n\n        align: function(targetBox, axis, alignment) {\n            this.box.align(targetBox, axis, alignment);\n        },\n\n        hasBox: function() {\n            var options = this.options;\n            return options.border.width || options.background;\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            var options = this.options;\n            if (options.visible && this.hasBox()) {\n                this.visual.append(Path.fromRect(\n                    this.paddingBox.toRect(),\n                    this.visualStyle()\n                ));\n            }\n        },\n\n        visualStyle: function() {\n            var options = this.options;\n            var border = options.border || {};\n\n            return {\n                stroke: {\n                    width: border.width,\n                    color: border.color,\n                    opacity: valueOrDefault(border.opacity, options.opacity),\n                    dashType: border.dashType\n                },\n                fill: {\n                    color: options.background,\n                    opacity: options.opacity\n                },\n                cursor: options.cursor\n            };\n        }\n    });\n\n    setDefaultOptions(BoxElement, {\n        align: LEFT,\n        vAlign: TOP,\n        margin: {},\n        padding: {},\n        border: {\n            color: BLACK,\n            width: 0\n        },\n        background: \"\",\n        shrinkToFit: false,\n        width: 0,\n        height: 0,\n        visible: true\n    });\n\n    function addAccessibilityAttributesToVisual(visual, accessibilityOptions) {\n        if (accessibilityOptions) {\n            visual.options.className = accessibilityOptions.className;\n            visual.options.role = accessibilityOptions.role;\n            visual.options.ariaLabel = accessibilityOptions.ariaLabel;\n            visual.options.ariaRoleDescription = accessibilityOptions.ariaRoleDescription;\n            visual.options.ariaChecked = accessibilityOptions.ariaChecked;\n        }\n    }\n\n    var ShapeElement = BoxElement.extend({\n        init: function(options, pointData) {\n            BoxElement.fn.init.call(this, options);\n\n            this.pointData = pointData;\n        },\n\n        getElement: function() {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.paddingBox;\n            var type = options.type;\n            var rotation = options.rotation;\n            var center = box.center();\n            var halfWidth = box.width() / 2;\n            var halfHeight = box.height() / 2;\n\n            if (!options.visible || !this.hasBox()) {\n                return null;\n            }\n\n            var style = this.visualStyle();\n            var element;\n\n            if (type === CIRCLE) {\n                element = new drawing.Circle(\n                    new Circle([\n                        round(box.x1 + halfWidth, COORD_PRECISION),\n                        round(box.y1 + halfHeight, COORD_PRECISION)\n                    ], Math.min(halfWidth, halfHeight)),\n                    style\n                );\n            } else if (type === TRIANGLE) {\n                element = Path.fromPoints([\n                    [ box.x1 + halfWidth, box.y1 ],\n                    [ box.x1, box.y2 ],\n                    [ box.x2, box.y2 ]\n                ], style).close();\n            } else if (type === CROSS) {\n                element = new drawing.MultiPath(style);\n\n                element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);\n                element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);\n            } else {\n                var rect = box.toRect();\n                if (type === ROUNDED_RECT) {\n                    var borderRadius = valueOrDefault(options.borderRadius, rect.width() / 5);\n                    rect.setCornerRadius(borderRadius);\n                }\n\n                element = Path.fromRect(rect, style);\n            }\n\n            if (rotation) {\n                element.transform(geometryTransform()\n                    .rotate(-rotation, [ center.x, center.y ])\n                );\n            }\n\n            element.options.zIndex = options.zIndex;\n\n            return element;\n        },\n\n        createElement: function() {\n            var this$1$1 = this;\n\n            var customVisual = this.options.visual;\n            var pointData = this.pointData || {};\n            var visual;\n\n            if (customVisual) {\n                visual = customVisual({\n                    value: pointData.value,\n                    dataItem: pointData.dataItem,\n                    sender: this.getSender(),\n                    series: pointData.series,\n                    category: pointData.category,\n                    rect: this.paddingBox.toRect(),\n                    options: this.visualOptions(),\n                    createVisual: function () { return this$1$1.getElement(); }\n                });\n            } else {\n                visual = this.getElement();\n            }\n\n            return visual;\n        },\n\n        visualOptions: function() {\n            var options = this.options;\n            return {\n                background: options.background,\n                border: options.border,\n                margin: options.margin,\n                padding: options.padding,\n                type: options.type,\n                size: options.width,\n                visible: options.visible\n            };\n        },\n\n        createVisual: function() {\n            this.visual = this.createElement();\n\n            addAccessibilityAttributesToVisual(this.visual, this.options.accessibilityOptions);\n        }\n    });\n\n    setDefaultOptions(ShapeElement, {\n        type: CIRCLE,\n        align: CENTER,\n        vAlign: CENTER\n    });\n\n    var LINEAR = \"linear\";\n    var RADIAL = \"radial\";\n\n    var GRADIENTS = {\n        glass: {\n            type: LINEAR,\n            rotation: 0,\n            stops: [ {\n                offset: 0,\n                color: WHITE,\n                opacity: 0\n            }, {\n                offset: 0.25,\n                color: WHITE,\n                opacity: 0.3\n            }, {\n                offset: 1,\n                color: WHITE,\n                opacity: 0\n            } ]\n        },\n        sharpBevel: {\n            type: RADIAL,\n            stops: [ {\n                offset: 0,\n                color: WHITE,\n                opacity: 0.55\n            }, {\n                offset: 0.65,\n                color: WHITE,\n                opacity: 0\n            }, {\n                offset: 0.95,\n                color: WHITE,\n                opacity: 0.25\n            } ]\n        },\n        roundedBevel: {\n            type: RADIAL,\n            stops: [ {\n                offset: 0.33,\n                color: WHITE,\n                opacity: 0.06\n            }, {\n                offset: 0.83,\n                color: WHITE,\n                opacity: 0.2\n            }, {\n                offset: 0.95,\n                color: WHITE,\n                opacity: 0\n            } ]\n        },\n        roundedGlass: {\n            type: RADIAL,\n            supportVML: false,\n            stops: [ {\n                offset: 0,\n                color: WHITE,\n                opacity: 0\n            }, {\n                offset: 0.5,\n                color: WHITE,\n                opacity: 0.3\n            }, {\n                offset: 0.99,\n                color: WHITE,\n                opacity: 0\n            } ]\n        },\n        sharpGlass: {\n            type: RADIAL,\n            supportVML: false,\n            stops: [ {\n                offset: 0,\n                color: WHITE,\n                opacity: 0.2\n            }, {\n                offset: 0.15,\n                color: WHITE,\n                opacity: 0.15\n            }, {\n                offset: 0.17,\n                color: WHITE,\n                opacity: 0.35\n            }, {\n                offset: 0.85,\n                color: WHITE,\n                opacity: 0.05\n            }, {\n                offset: 0.87,\n                color: WHITE,\n                opacity: 0.15\n            }, {\n                offset: 0.99,\n                color: WHITE,\n                opacity: 0\n            } ]\n        },\n        bubbleShadow: {\n            type: RADIAL,\n            center: [ 0.5, 0.5 ],\n            radius: 0.5\n        }\n    };\n\n    function boxDiff(r, s) {\n        if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {\n            return s;\n        }\n\n        var a = Math.min(r.x1, s.x1);\n        var b = Math.max(r.x1, s.x1);\n        var c = Math.min(r.x2, s.x2);\n        var d = Math.max(r.x2, s.x2);\n        var e = Math.min(r.y1, s.y1);\n        var f = Math.max(r.y1, s.y1);\n        var g = Math.min(r.y2, s.y2);\n        var h = Math.max(r.y2, s.y2);\n        var boxes = [];\n\n        // X = intersection, 0-7 = possible difference areas\n        // h +-+-+-+\n        // . |5|6|7|\n        // g +-+-+-+\n        // . |3|X|4|\n        // f +-+-+-+\n        // . |0|1|2|\n        // e +-+-+-+\n        // . a b c d\n\n        // we'll always have rectangles 1, 3, 4 and 6\n        boxes[0] = new Box(b, e, c, f);\n        boxes[1] = new Box(a, f, b, g);\n        boxes[2] = new Box(c, f, d, g);\n        boxes[3] = new Box(b, g, c, h);\n\n        // decide which corners\n        if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) { // corners 0 and 7\n            boxes[4] = new Box(a, e, b, f);\n            boxes[5] = new Box(c, g, d, h);\n        } else { // corners 2 and 5\n            boxes[4] = new Box(c, e, d, f);\n            boxes[5] = new Box(a, g, b, h);\n        }\n\n        return grep(boxes, function(box) {\n            return box.height() > 0 && box.width() > 0;\n        })[0];\n    }\n\n    var RootElement = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n\n            var rootOptions = this.options;\n            rootOptions.width = parseInt(rootOptions.width, 10);\n            rootOptions.height = parseInt(rootOptions.height, 10);\n\n            this.gradients = {};\n        },\n\n        reflow: function() {\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var currentBox = new Box(0, 0, options.width, options.height);\n\n            this.box = currentBox.unpad(options.margin);\n\n            for (var i = 0; i < children.length; i++) {\n                children[i].reflow(currentBox);\n                currentBox = boxDiff(currentBox, children[i].box) || new Box();\n            }\n        },\n\n        createVisual: function() {\n            this.visual = new Group();\n            this.createBackground();\n        },\n\n        createBackground: function() {\n            var options = this.options;\n            var border = options.border || {};\n            var box = this.box.clone().pad(options.margin).unpad(border.width);\n\n            var background = Path.fromRect(box.toRect(), {\n                stroke: {\n                    color: border.width ? border.color : \"\",\n                    width: border.width,\n                    dashType: border.dashType\n                },\n                fill: {\n                    color: options.background,\n                    opacity: options.opacity\n                },\n                zIndex: -10\n            });\n\n            this.visual.append(background);\n        },\n\n        getRoot: function() {\n            return this;\n        },\n\n        createGradient: function(options) {\n            var gradients = this.gradients;\n            var hashCode = objectKey(options);\n            var gradient = GRADIENTS[options.gradient];\n            var drawingGradient;\n\n            if (gradients[hashCode]) {\n                drawingGradient = gradients[hashCode];\n            } else {\n                var gradientOptions = $.extend({}, gradient, options);\n                if (gradient.type === \"linear\") {\n                    drawingGradient = new drawing.LinearGradient(gradientOptions);\n                } else {\n                    if (options.innerRadius) {\n                        gradientOptions.stops = innerRadialStops(gradientOptions);\n                    }\n                    drawingGradient = new drawing.RadialGradient(gradientOptions);\n                    drawingGradient.supportVML = gradient.supportVML !== false;\n                }\n                gradients[hashCode] = drawingGradient;\n            }\n\n            return drawingGradient;\n        },\n\n        cleanGradients: function() {\n            var gradients = this.gradients;\n            for (var hashCode in gradients) {\n                gradients[hashCode]._observers = [];//add clear observers method in drawing ObserversMixin\n            }\n        },\n\n        size: function() {\n            var options = this.options;\n            return new Box(0, 0, options.width, options.height);\n        }\n    });\n\n    setDefaultOptions(RootElement, {\n        width: DEFAULT_WIDTH,\n        height: DEFAULT_HEIGHT,\n        background: WHITE,\n        border: {\n            color: BLACK,\n            width: 0\n        },\n        margin: getSpacing(5),\n        zIndex: -2\n    });\n\n    function innerRadialStops(options) {\n        var stops = options.stops;\n        var usedSpace = ((options.innerRadius / options.radius) * 100);\n        var length = stops.length;\n        var currentStops = [];\n\n        for (var i = 0; i < length; i++) {\n            var currentStop = $.extend({}, stops[i]);\n            currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;\n            currentStops.push(currentStop);\n        }\n\n        return currentStops;\n    }\n\n    var FloatElement = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n            this._initDirection();\n        },\n\n        _initDirection: function() {\n            var options = this.options;\n            if (options.vertical) {\n                this.groupAxis = X;\n                this.elementAxis = Y;\n                this.groupSizeField = WIDTH;\n                this.elementSizeField = HEIGHT;\n                this.groupSpacing = options.spacing;\n                this.elementSpacing = options.vSpacing;\n            } else {\n                this.groupAxis = Y;\n                this.elementAxis = X;\n                this.groupSizeField = HEIGHT;\n                this.elementSizeField = WIDTH;\n                this.groupSpacing = options.vSpacing;\n                this.elementSpacing = options.spacing;\n            }\n        },\n\n        reflow: function(targetBox) {\n            this.box = targetBox.clone();\n            this.reflowChildren();\n        },\n\n        reflowChildren: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var box = ref.box;\n            var elementAxis = ref.elementAxis;\n            var groupAxis = ref.groupAxis;\n            var elementSizeField = ref.elementSizeField;\n            var groupSizeField = ref.groupSizeField;\n            var ref$1 = this.groupOptions();\n            var groups = ref$1.groups;\n            var groupsSize = ref$1.groupsSize;\n            var maxGroupElementsSize = ref$1.maxGroupElementsSize;\n            var groupsCount = groups.length;\n            var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());\n\n            if (groupsCount) {\n                var groupStart = groupsStart;\n\n                for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\n                    var group = groups[groupIdx];\n                    var groupElements = group.groupElements;\n                    var elementStart = box[elementAxis + 1];\n                    var groupElementsCount = groupElements.length;\n\n                    for (var idx = 0; idx < groupElementsCount; idx++) {\n                        var element = groupElements[idx];\n                        var elementSize$$1 = this$1$1.elementSize(element);\n                        var groupElementStart = groupStart + this$1$1.alignStart(elementSize$$1[groupSizeField], group.groupSize);\n\n                        var elementBox = new Box();\n                        elementBox[groupAxis + 1] = groupElementStart;\n                        elementBox[groupAxis + 2] = groupElementStart + elementSize$$1[groupSizeField];\n                        elementBox[elementAxis + 1] = elementStart;\n                        elementBox[elementAxis + 2] = elementStart + elementSize$$1[elementSizeField];\n\n                        element.reflow(elementBox);\n\n                        elementStart += elementSize$$1[elementSizeField] + this$1$1.elementSpacing;\n                    }\n                    groupStart += group.groupSize + this$1$1.groupSpacing;\n                }\n                box[groupAxis + 1] = groupsStart;\n                box[groupAxis + 2] = groupsStart + groupsSize;\n                box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;\n            }\n        },\n\n        alignStart: function(size, maxSize) {\n            var start = 0;\n            var align = this.options.align;\n            if (align === RIGHT || align === BOTTOM) {\n                start = maxSize - size;\n            } else if (align === CENTER) {\n                start = (maxSize - size) / 2;\n            }\n            return start;\n        },\n\n        groupOptions: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var box = ref.box;\n            var children = ref.children;\n            var elementSizeField = ref.elementSizeField;\n            var groupSizeField = ref.groupSizeField;\n            var elementSpacing = ref.elementSpacing;\n            var groupSpacing = ref.groupSpacing;\n            var maxSize = round(box[elementSizeField]());\n            var childrenCount = children.length;\n            var groups = [];\n\n            var groupSize = 0;\n            var groupElementsSize = 0;\n            var groupsSize = 0;\n            var maxGroupElementsSize = 0;\n            var groupElements = [];\n\n            for (var idx = 0; idx < childrenCount; idx++) {\n                var element = children[idx];\n                if (!element.box) {\n                    element.reflow(box);\n                }\n\n                var elementSize$$1 = this$1$1.elementSize(element);\n                if (this$1$1.options.wrap && round(groupElementsSize + elementSpacing + elementSize$$1[elementSizeField]) > maxSize) {\n                    groups.push({\n                        groupElements: groupElements,\n                        groupSize: groupSize,\n                        groupElementsSize: groupElementsSize\n                    });\n                    maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n                    groupsSize += groupSpacing + groupSize;\n                    groupSize = 0;\n                    groupElementsSize = 0;\n                    groupElements = [];\n                }\n                groupSize = Math.max(groupSize, elementSize$$1[groupSizeField]);\n                if (groupElementsSize > 0) {\n                    groupElementsSize += elementSpacing;\n                }\n                groupElementsSize += elementSize$$1[elementSizeField];\n                groupElements.push(element);\n            }\n\n            groups.push({\n                groupElements: groupElements,\n                groupSize: groupSize,\n                groupElementsSize: groupElementsSize\n            });\n            maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n            groupsSize += groupSize;\n\n            return {\n                groups: groups,\n                groupsSize: groupsSize,\n                maxGroupElementsSize: maxGroupElementsSize\n            };\n        },\n\n        elementSize: function(element) {\n            return {\n                width: element.box.width(),\n                height: element.box.height()\n            };\n        },\n\n        createVisual: function() {}\n    });\n\n    setDefaultOptions(FloatElement, {\n        vertical: true,\n        wrap: true,\n        vSpacing: 0,\n        spacing: 0\n    });\n\n    var DrawingText = drawing.Text;\n\n    var Text = ChartElement.extend({\n        init: function(content, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.content = content;\n\n            // Calculate size\n            this.reflow(new Box());\n        },\n\n        reflow: function(targetBox) {\n            var options = this.options;\n            var size = options.size = util.measureText(this.content, { font: options.font });\n\n            this.baseline = size.baseline;\n\n            this.box = new Box(targetBox.x1, targetBox.y1,\n                targetBox.x1 + size.width, targetBox.y1 + size.height);\n        },\n\n        createVisual: function() {\n            var ref = this.options;\n            var font = ref.font;\n            var color = ref.color;\n            var opacity = ref.opacity;\n            var cursor = ref.cursor;\n\n            this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {\n                font: font,\n                fill: { color: color, opacity: opacity },\n                cursor: cursor\n            });\n        }\n    });\n\n    setDefaultOptions(Text, {\n        font: DEFAULT_FONT,\n        color: BLACK\n    });\n\n    function rectToBox(rect) {\n        var origin = rect.origin;\n        var bottomRight = rect.bottomRight();\n\n        return new Box(origin.x, origin.y, bottomRight.x, bottomRight.y);\n    }\n\n    var ROWS_SPLIT_REGEX = /\\n/m;\n\n    var TextBox = BoxElement.extend({\n        init: function(content, options, data) {\n            BoxElement.fn.init.call(this, options);\n            this.content = content;\n            this.data = data;\n\n            this._initContainer();\n            if (this.options._autoReflow !== false) {\n                this.reflow(new Box());\n            }\n        },\n\n        _initContainer: function() {\n            var options = this.options;\n            var rows = String(this.content).split(ROWS_SPLIT_REGEX);\n            var floatElement = new FloatElement({ vertical: true, align: options.align, wrap: false });\n            var textOptions = deepExtend({ }, options, { opacity: 1, animation: null });\n\n            this.container = floatElement;\n            this.append(floatElement);\n\n            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {\n                var text = new Text(rows[rowIdx].trim(), textOptions);\n                floatElement.append(text);\n            }\n        },\n\n        reflow: function(targetBox) {\n            var options = this.options;\n            var visualFn = options.visual;\n            this.container.options.align = options.align;\n\n            if (visualFn && !this._boxReflow) {\n                var visualBox = targetBox;\n                if (!visualBox.hasSize()) {\n                    this._boxReflow = true;\n                    this.reflow(visualBox);\n                    this._boxReflow = false;\n                    visualBox = this.box;\n                }\n                var visual = this.visual = visualFn(this.visualContext(visualBox));\n\n                if (visual) {\n                    visualBox = rectToBox(visual.clippedBBox() || new Rect());\n\n                    visual.options.zIndex = options.zIndex;\n                }\n\n                this.box = this.contentBox = this.paddingBox = visualBox;\n            } else {\n                BoxElement.fn.reflow.call(this, targetBox);\n\n                if (options.rotation) {\n                    var margin = getSpacing(options.margin);\n                    var box = this.box.unpad(margin);\n\n                    this.targetBox = targetBox;\n                    this.normalBox = box.clone();\n\n                    box = this.rotate();\n                    box.translate(margin.left - margin.right, margin.top - margin.bottom);\n\n                    this.rotatedBox = box.clone();\n\n                    box.pad(margin);\n                }\n            }\n        },\n\n        createVisual: function() {\n            var options = this.options;\n\n            this.visual = new Group({\n                transform: this.rotationTransform(),\n                zIndex: options.zIndex,\n                noclip: options.noclip\n            });\n\n            if (this.hasBox()) {\n                var box = Path.fromRect(this.paddingBox.toRect(), this.visualStyle());\n                this.visual.append(box);\n            }\n        },\n\n        renderVisual: function() {\n            if (!this.options.visible) {\n                return;\n            }\n\n            if (this.options.visual) {\n                var visual = this.visual;\n                if (visual && !defined(visual.options.noclip)) {\n                    visual.options.noclip = this.options.noclip;\n                }\n                this.addVisual();\n                this.createAnimation();\n            } else {\n                BoxElement.fn.renderVisual.call(this);\n            }\n        },\n\n        visualContext: function(targetBox) {\n            var this$1$1 = this;\n\n            var context = {\n                text: this.content,\n                rect: targetBox.toRect(),\n                sender: this.getSender(),\n                options: this.options,\n                createVisual: function () {\n                    this$1$1._boxReflow = true;\n                    this$1$1.reflow(targetBox);\n                    this$1$1._boxReflow = false;\n                    return this$1$1.getDefaultVisual();\n                }\n            };\n            if (this.data) {\n                $.extend(context, this.data);\n            }\n\n            return context;\n        },\n\n        getDefaultVisual: function() {\n            this.createVisual();\n            this.renderChildren();\n            var visual = this.visual;\n            delete this.visual;\n            return visual;\n        },\n\n        rotate: function() {\n            var options = this.options;\n            this.box.rotate(options.rotation);\n            this.align(this.targetBox, X, options.align);\n            this.align(this.targetBox, Y, options.vAlign);\n            return this.box;\n        },\n\n        rotationTransform: function() {\n            var rotation = this.options.rotation;\n            if (!rotation) {\n                return null;\n            }\n\n            var ref = this.normalBox.center();\n            var cx = ref.x;\n            var cy = ref.y;\n            var boxCenter = this.rotatedBox.center();\n\n            return geometryTransform()\n                .translate(boxCenter.x - cx, boxCenter.y - cy)\n                .rotate(rotation, [ cx, cy ]);\n        }\n    });\n\n    var Title = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n\n            this._textBox = new TextBox(this.options.text, $.extend({}, this.options, {\n                vAlign: this.options.position\n            }));\n\n            this.append(this._textBox);\n        },\n\n        reflow: function(targetBox) {\n            ChartElement.fn.reflow.call(this, targetBox);\n            this.box.snapTo(targetBox, X);\n        }\n    });\n\n    Title.buildTitle = function(options, defaultOptions) {\n        var titleOptions = options;\n\n        if (typeof options === \"string\") {\n            titleOptions = { text: options };\n        }\n\n        titleOptions = $.extend({ visible: true }, defaultOptions, titleOptions);\n\n        var title;\n        if (titleOptions && titleOptions.visible && titleOptions.text) {\n            title = new Title(titleOptions);\n        }\n\n        return title;\n    };\n\n    Title.orderTitles = function(titles) {\n        var items = [].concat(titles);\n        var top = items.filter(function (item) { return item && item.options.position !== BOTTOM; });\n        var bottom = items.filter(function (item) { return item && item.options.position === BOTTOM; });\n\n        collapseVerticalMargins(top);\n        collapseVerticalMargins(bottom);\n\n        bottom.reverse();\n        return top.concat(bottom);\n    };\n\n    function collapseVerticalMargins(items) {\n        for (var i = 1; i < items.length; i++) {\n            var box = items[i]._textBox;\n            var prevBox = items[i - 1]._textBox;\n            prevBox.options.margin = $.extend(getSpacing(prevBox.options.margin), { bottom: 0 });\n            box.options.margin = $.extend(getSpacing(box.options.margin), { top: 0 });\n        }\n    }\n\n    setDefaultOptions(Title, {\n        color: BLACK,\n        position: TOP,\n        align: CENTER,\n        margin: getSpacing(5),\n        padding: getSpacing(5)\n    });\n\n    var AxisLabel = TextBox.extend({\n        init: function(value, text, index, dataItem, options) {\n            TextBox.fn.init.call(this, text, options);\n\n            this.text = text;\n            this.value = value;\n            this.index = index;\n            this.dataItem = dataItem;\n            this.reflow(new Box());\n        },\n\n        visualContext: function(targetBox) {\n            var context = TextBox.fn.visualContext.call(this, targetBox);\n\n            context.value = this.value;\n            context.dataItem = this.dataItem;\n            context.format = this.options.format;\n            context.culture = this.options.culture;\n\n            return context;\n        },\n\n        click: function(widget, e) {\n\n            widget.trigger(AXIS_LABEL_CLICK, {\n                element: eventElement(e),\n                value: this.value,\n                text: this.text,\n                index: this.index,\n                dataItem: this.dataItem,\n                axis: this.parent.options\n            });\n        },\n\n        rotate: function() {\n            if (this.options.alignRotation !== CENTER) {\n                var box = this.normalBox.toRect();\n                var transform = this.rotationTransform();\n\n                this.box = rectToBox(box.bbox(transform.matrix()));\n            } else {\n                TextBox.fn.rotate.call(this);\n            }\n\n            return this.box;\n        },\n\n        rotationTransform: function() {\n            var options = this.options;\n            var rotation = options.rotation;\n            if (!rotation) {\n                return null;\n            }\n\n            if (options.alignRotation === CENTER) {\n                return TextBox.fn.rotationTransform.call(this);\n            }\n\n            var rotationMatrix = geometryTransform().rotate(rotation).matrix();\n            var box = this.normalBox.toRect();\n            var rect = this.targetBox.toRect();\n\n            var rotationOrigin = options.rotationOrigin || TOP;\n            var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;\n            var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;\n            var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();\n\n            var topLeft = box.topLeft().transformCopy(rotationMatrix);\n            var topRight = box.topRight().transformCopy(rotationMatrix);\n            var bottomRight = box.bottomRight().transformCopy(rotationMatrix);\n            var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);\n            var rotatedBox = Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);\n\n            var translate = {};\n            translate[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];\n\n            var distanceLeft = Math.abs(topLeft[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n            var distanceRight = Math.abs(topRight[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n\n            var alignStart, alignEnd;\n\n            if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {\n                alignStart = topLeft;\n                alignEnd = topRight;\n            } else if (distanceRight < distanceLeft) {\n                alignStart = topRight;\n                alignEnd = bottomRight;\n            } else {\n                alignStart = topLeft;\n                alignEnd = bottomLeft;\n            }\n\n            var alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;\n            translate[alignAxis] = rect.center()[alignAxis] - alignCenter;\n\n            return geometryTransform()\n                .translate(translate.x, translate.y)\n                .rotate(rotation);\n        }\n    });\n\n    setDefaultOptions(AxisLabel, {\n        _autoReflow: false\n    });\n\n    var DEFAULT_ICON_SIZE = 7;\n    var DEFAULT_LABEL_COLOR = \"#fff\";\n\n    var Note = BoxElement.extend({\n        init: function(fields, options, chartService) {\n            BoxElement.fn.init.call(this, options);\n\n            this.fields = fields;\n            this.chartService = chartService;\n\n            this.render();\n        },\n\n        hide: function() {\n            this.options.visible = false;\n        },\n\n        show: function() {\n            this.options.visible = true;\n        },\n\n        render: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n\n            if (options.visible) {\n                var label = options.label;\n                var icon = options.icon;\n                var box = new Box();\n                var childAlias = function () { return this$1$1; };\n                var size = icon.size;\n                var text = this.fields.text;\n                var width, height;\n\n                if (defined(label) && label.visible) {\n                    var noteTemplate = getTemplate(label);\n                    if (noteTemplate) {\n                        text = noteTemplate(this.fields);\n                    } else if (label.format) {\n                        text = this.chartService.format.auto(label.format, text);\n                    }\n\n                    if (!label.color) {\n                        label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n                    }\n\n                    this.label = new TextBox(text, deepExtend({}, label));\n                    this.label.aliasFor = childAlias;\n\n                    if (label.position === INSIDE && !defined(size)) {\n                        if (icon.type === CIRCLE) {\n                            size = Math.max(this.label.box.width(), this.label.box.height());\n                        } else {\n                            width = this.label.box.width();\n                            height = this.label.box.height();\n                        }\n                        box.wrap(this.label.box);\n                    }\n                }\n\n                icon.width = width || size || DEFAULT_ICON_SIZE;\n                icon.height = height || size || DEFAULT_ICON_SIZE;\n\n                var marker = new ShapeElement(deepExtend({}, icon));\n                marker.aliasFor = childAlias;\n\n                this.marker = marker;\n                this.append(marker);\n\n                if (this.label) {\n                    this.append(this.label);\n                }\n\n                marker.reflow(new Box());\n                this.wrapperBox = box.wrap(marker.box);\n            }\n        },\n\n        reflow: function(targetBox) {\n            var ref = this;\n            var options = ref.options;\n            var label = ref.label;\n            var marker = ref.marker;\n            var wrapperBox = ref.wrapperBox;\n            var center = targetBox.center();\n            var length = options.line.length;\n            var position = options.position;\n\n            // TODO: Review\n            if (options.visible) {\n                var lineStart, box, contentBox;\n\n                if (inArray(position, [ LEFT, RIGHT ])) {\n                    if (position === LEFT) {\n                        contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n\n                        if (options.line.visible) {\n                            lineStart = [ targetBox.x1, center.y ];\n                            this.linePoints = [\n                                lineStart,\n                                [ contentBox.x2, center.y ]\n                            ];\n                            box = contentBox.clone().wrapPoint(lineStart);\n                        }\n                    } else {\n                        contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n\n                        if (options.line.visible) {\n                            lineStart = [ targetBox.x2, center.y ];\n                            this.linePoints = [\n                                lineStart,\n                                [ contentBox.x1, center.y ]\n                            ];\n                            box = contentBox.clone().wrapPoint(lineStart);\n                        }\n                    }\n                } else {\n                    if (position === BOTTOM) {\n                        contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n\n                        if (options.line.visible) {\n                            lineStart = [ center.x, targetBox.y2 ];\n                            this.linePoints = [\n                                lineStart,\n                                [ center.x, contentBox.y1 ]\n                            ];\n                            box = contentBox.clone().wrapPoint(lineStart);\n                        }\n                    } else {\n                        contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n\n                        if (options.line.visible) {\n                            lineStart = [ center.x, targetBox.y1 ];\n                            this.linePoints = [\n                                lineStart,\n                                [ center.x, contentBox.y2 ]\n                            ];\n                            box = contentBox.clone().wrapPoint(lineStart);\n                        }\n                    }\n                }\n\n                if (marker) {\n                    marker.reflow(contentBox);\n                }\n\n                if (label) {\n                    label.reflow(contentBox);\n                    if (marker) {\n                        if (options.label.position === OUTSIDE) {\n                            label.box.alignTo(marker.box, position);\n                        }\n                        label.reflow(label.box);\n                    }\n                }\n\n                this.contentBox = contentBox;\n                this.targetBox = targetBox;\n                this.box = box || contentBox;\n            }\n        },\n\n        createVisual: function() {\n            BoxElement.fn.createVisual.call(this);\n            this.visual.options.noclip = this.options.noclip;\n\n            if (this.options.visible) {\n                this.createLine();\n            }\n        },\n\n        renderVisual: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var customVisual = options.visual;\n            if (options.visible && customVisual) {\n                this.visual = customVisual($.extend(this.fields, {\n                    sender: this.getSender(),\n                    rect: this.targetBox.toRect(),\n                    options: {\n                        background: options.background,\n                        border: options.background,\n                        icon: options.icon,\n                        label: options.label,\n                        line: options.line,\n                        position: options.position,\n                        visible: options.visible\n                    },\n                    createVisual: function () {\n                        this$1$1.createVisual();\n                        this$1$1.renderChildren();\n                        var defaultVisual = this$1$1.visual;\n                        delete this$1$1.visual;\n                        return defaultVisual;\n                    }\n                }));\n                this.addVisual();\n            } else {\n                BoxElement.fn.renderVisual.call(this);\n            }\n        },\n\n        createLine: function() {\n            var options = this.options.line;\n\n            if (this.linePoints) {\n                var path = Path.fromPoints(this.linePoints, {\n                    stroke: {\n                        color: options.color,\n                        width: options.width,\n                        dashType: options.dashType\n                    }\n                });\n\n                alignPathToPixel(path);\n                this.visual.append(path);\n            }\n        },\n\n        click: function(widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(NOTE_CLICK, args)) {\n                e.preventDefault();\n            }\n        },\n\n        over: function(widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(NOTE_HOVER, args)) {\n                e.preventDefault();\n            }\n        },\n\n        out: function(widget, e) {\n            var args = this.eventArgs(e);\n\n            widget.trigger(NOTE_LEAVE, args);\n        },\n\n        eventArgs: function(e) {\n            var options = this.options;\n\n            return $.extend(this.fields, {\n                element: eventElement(e),\n                text: defined(options.label) ? options.label.text : \"\",\n                visual: this.visual\n            });\n        }\n    });\n\n    setDefaultOptions(Note, {\n        icon: {\n            visible: true,\n            type: CIRCLE\n        },\n        label: {\n            position: INSIDE,\n            visible: true,\n            align: CENTER,\n            vAlign: CENTER\n        },\n        line: {\n            visible: true\n        },\n        visible: true,\n        position: TOP,\n        zIndex: 2\n    });\n\n    var defaultImplementation = {\n        format: function (format, value) { return value; },\n\n        toString: function (value) { return value; },\n\n        parseDate: function (value) { return new Date(value); },\n\n        firstDay: function () { return 0; }\n    };\n\n    var current$1 = defaultImplementation;\n\n    var IntlService = Class.extend({\n\n    });\n\n    IntlService.register = function(userImplementation) {\n        current$1 = userImplementation;\n    };\n\n    if (Object.defineProperties) {\n        Object.defineProperties(IntlService, {\n            implementation: {\n                get: function() {\n                    return current$1;\n                }\n            }\n        });\n    }\n\n    // eslint-disable-next-line no-useless-escape\n    var FORMAT_REPLACE_REGEX = /\\{(\\d+)(:[^\\}]+)?\\}/g;\n\n    var FormatService = Class.extend({\n        init: function(intlService) {\n            this._intlService = intlService;\n        },\n\n        auto: function(formatString) {\n            var values = [], len = arguments.length - 1;\n            while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n            var intl = this.intl;\n\n            if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n                return intl.format.apply(intl, [ formatString ].concat( values ));\n            }\n\n            return intl.toString(values[0], formatString);\n        },\n\n        localeAuto: function(formatString, values, locale) {\n            var intl = this.intl;\n            var result;\n\n            if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n                result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {\n                    var value = values[parseInt(index, 10)];\n\n                    return intl.toString(value, placeholderFormat ? placeholderFormat.substring(1) : \"\", locale);\n                });\n            } else {\n                result = intl.toString(values[0], formatString, locale);\n            }\n\n            return result;\n        }\n    });\n\n    if (Object.defineProperties) {\n        Object.defineProperties(FormatService.fn, {\n            intl: {\n                get: function() {\n                    return this._intlService || IntlService.implementation;\n                },\n                set: function(value) {\n                    this._intlService = value;\n                }\n            }\n        });\n    }\n\n    var ChartService = Class.extend({\n        init: function(chart, context) {\n            if (context === void 0) { context = {}; }\n\n            this._intlService = context.intlService;\n            this.sender = context.sender || chart;\n            this.format = new FormatService(context.intlService);\n            this.chart = chart;\n            this.rtl = Boolean(context.rtl);\n        },\n\n        notify: function(name, args) {\n            if (this.chart) {\n                this.chart.trigger(name, args);\n            }\n        },\n\n        isPannable: function(axis) {\n            var pannable = ((this.chart || {}).options || {}).pannable;\n            return pannable && pannable.lock !== axis;\n        }\n    });\n\n    if (Object.defineProperties) {\n        Object.defineProperties(ChartService.fn, {\n            intl: {\n                get: function() {\n                    return this._intlService || IntlService.implementation;\n                },\n                set: function(value) {\n                    this._intlService = value;\n                    this.format.intl = value;\n                }\n            }\n        });\n    }\n\n    var current$2;\n\n    var DomEventsBuilder = Class.extend({\n\n    });\n\n    DomEventsBuilder.register = function(userImplementation) {\n        current$2 = userImplementation;\n    };\n\n    DomEventsBuilder.create = function(element, events) {\n        if (current$2) {\n            return current$2.create(element, events);\n        }\n    };\n\n    var services = {\n    \tChartService: ChartService,\n    \tDomEventsBuilder: DomEventsBuilder,\n    \tFormatService: FormatService,\n    \tIntlService: IntlService,\n    \tTemplateService: TemplateService\n    };\n\n    function createAxisTick(options, tickOptions) {\n        var tickX = options.tickX;\n        var tickY = options.tickY;\n        var position = options.position;\n\n        var tick = new Path({\n            stroke: {\n                width: tickOptions.width,\n                color: tickOptions.color\n            }\n        });\n\n        if (options.vertical) {\n            tick.moveTo(tickX, position)\n                .lineTo(tickX + tickOptions.size, position);\n        } else {\n            tick.moveTo(position, tickY)\n                .lineTo(position, tickY + tickOptions.size);\n        }\n\n        alignPathToPixel(tick);\n\n        return tick;\n    }\n\n    function createAxisGridLine(options, gridLine) {\n        var lineStart = options.lineStart;\n        var lineEnd = options.lineEnd;\n        var position = options.position;\n\n        var line = new Path({\n            stroke: {\n                width: gridLine.width,\n                color: gridLine.color,\n                dashType: gridLine.dashType\n            }\n        });\n\n        if (options.vertical) {\n            line.moveTo(lineStart, position)\n                .lineTo(lineEnd, position);\n        } else {\n            line.moveTo(position, lineStart)\n                .lineTo(position, lineEnd);\n        }\n\n        alignPathToPixel(line);\n\n        return line;\n    }\n\n    var Axis = ChartElement.extend({\n        init: function(options, chartService) {\n            if (chartService === void 0) { chartService = new ChartService(); }\n\n            ChartElement.fn.init.call(this, options);\n\n            this.chartService = chartService;\n\n            if (!this.options.visible) {\n                this.options = deepExtend({}, this.options, {\n                    labels: {\n                        visible: false\n                    },\n                    line: {\n                        visible: false\n                    },\n                    margin: 0,\n                    majorTickSize: 0,\n                    minorTickSize: 0\n                });\n            }\n\n            this.options.minorTicks = deepExtend({}, {\n                color: this.options.line.color,\n                width: this.options.line.width,\n                visible: this.options.minorTickType !== NONE\n            }, this.options.minorTicks, {\n                size: this.options.minorTickSize,\n                align: this.options.minorTickType\n            });\n\n            this.options.majorTicks = deepExtend({}, {\n                color: this.options.line.color,\n                width: this.options.line.width,\n                visible: this.options.majorTickType !== NONE\n            }, this.options.majorTicks, {\n                size: this.options.majorTickSize,\n                align: this.options.majorTickType\n            });\n\n            this.initFields();\n\n            if (!this.options._deferLabels) {\n                this.createLabels();\n            }\n\n            this.createTitle();\n            this.createNotes();\n        },\n\n        initFields: function() {\n        },\n\n        labelsRange: function() {\n            return {\n                min: this.options.labels.skip,\n                max: this.labelsCount()\n            };\n        },\n\n        normalizeLabelRotation: function(labelOptions) {\n            var rotation = labelOptions.rotation;\n\n            if (isObject(rotation)) {\n                labelOptions.alignRotation = rotation.align;\n                labelOptions.rotation = rotation.angle;\n            }\n        },\n\n        createLabels: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var align = options.vertical ? RIGHT : CENTER;\n            var labelOptions = deepExtend({ }, options.labels, {\n                align: align,\n                zIndex: options.zIndex\n            });\n            var step = Math.max(1, labelOptions.step);\n\n            this.clearLabels();\n\n            if (labelOptions.visible) {\n                this.normalizeLabelRotation(labelOptions);\n                if (labelOptions.rotation === \"auto\") {\n                    labelOptions.rotation = 0;\n                    options.autoRotateLabels = true;\n                }\n\n                var range = this.labelsRange();\n                for (var idx = range.min; idx < range.max; idx += step) {\n                    var labelContext = { index: idx, count: range.max };\n                    var label = this$1$1.createAxisLabel(idx, labelOptions, labelContext);\n                    if (label) {\n                        this$1$1.append(label);\n                        this$1$1.labels.push(label);\n                    }\n                }\n            }\n        },\n\n        clearLabels: function() {\n            this.children = grep(this.children, function (child) { return !(child instanceof AxisLabel); });\n            this.labels = [];\n        },\n\n        clearTitle: function() {\n            var this$1$1 = this;\n\n            if (this.title) {\n                this.children = grep(this.children, function (child) { return child !== this$1$1.title; });\n                this.title = undefined;\n            }\n        },\n\n        clear: function() {\n            this.clearLabels();\n            this.clearTitle();\n        },\n\n        lineBox: function() {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var axisX = mirror ? box.x1 : box.x2;\n            var axisY = mirror ? box.y2 : box.y1;\n            var lineWidth = options.line.width || 0;\n\n            return vertical ?\n                new Box(axisX, box.y1, axisX, box.y2 - lineWidth) :\n                new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n        },\n\n        createTitle: function() {\n            var options = this.options;\n            var titleOptions = deepExtend({\n                rotation: options.vertical ? -90 : 0,\n                text: \"\",\n                zIndex: 1,\n                visualSize: true\n            }, options.title);\n\n            if (titleOptions.visible && titleOptions.text) {\n                var title = new TextBox(titleOptions.text, titleOptions);\n                this.append(title);\n                this.title = title;\n            }\n        },\n\n        createNotes: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var notes = options.notes;\n            var items = notes.data || [];\n\n            this.notes = [];\n\n            for (var i = 0; i < items.length; i++) {\n                var item = deepExtend({}, notes, items[i]);\n                item.value = this$1$1.parseNoteValue(item.value);\n\n                var note = new Note({\n                    value: item.value,\n                    text: item.label.text,\n                    dataItem: item\n                }, item, this$1$1.chartService);\n\n                if (note.options.visible) {\n                    if (defined(note.options.position)) {\n                        if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\n                            note.options.position = options.reverse ? LEFT : RIGHT;\n                        } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\n                            note.options.position = options.reverse ? BOTTOM : TOP;\n                        }\n                    } else {\n                        if (options.vertical) {\n                            note.options.position = options.reverse ? LEFT : RIGHT;\n                        } else {\n                            note.options.position = options.reverse ? BOTTOM : TOP;\n                        }\n                    }\n                    this$1$1.append(note);\n                    this$1$1.notes.push(note);\n                }\n            }\n        },\n\n        parseNoteValue: function(value) {\n            return value;\n        },\n\n        renderVisual: function() {\n            ChartElement.fn.renderVisual.call(this);\n\n            this.createPlotBands();\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            this.createBackground();\n            this.createLine();\n        },\n\n        gridLinesVisual: function() {\n            var gridLines = this._gridLines;\n            if (!gridLines) {\n                gridLines = this._gridLines = new Group({\n                    zIndex: -2\n                });\n                this.appendVisual(this._gridLines);\n            }\n\n            return gridLines;\n        },\n\n        createTicks: function(lineGroup) {\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var mirror = options.labels.mirror;\n            var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n            var tickLineOptions = {\n                // TODO\n                // _alignLines: options._alignLines,\n                vertical: options.vertical\n            };\n\n            function render(tickPositions, tickOptions, skipUnit) {\n                var count = tickPositions.length;\n                var step = Math.max(1, tickOptions.step);\n\n                if (tickOptions.visible) {\n                    for (var i = tickOptions.skip; i < count; i += step) {\n                        if (defined(skipUnit) && (i % skipUnit === 0)) {\n                            continue;\n                        }\n\n                        tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                        tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                        tickLineOptions.position = tickPositions[i];\n\n                        lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n                    }\n                }\n            }\n\n            render(this.getMajorTickPositions(), options.majorTicks);\n            render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n        },\n\n        createLine: function() {\n            var options = this.options;\n            var line = options.line;\n            var lineBox = this.lineBox();\n\n            if (line.width > 0 && line.visible) {\n                var path = new Path({\n                    stroke: {\n                        width: line.width,\n                        color: line.color,\n                        dashType: line.dashType\n                    }\n\n                    /* TODO\n                    zIndex: line.zIndex,\n                    */\n                });\n\n                path.moveTo(lineBox.x1, lineBox.y1)\n                    .lineTo(lineBox.x2, lineBox.y2);\n\n                if (options._alignLines) {\n                    alignPathToPixel(path);\n                }\n\n                var group = this._lineGroup = new Group();\n                group.append(path);\n\n                this.visual.append(group);\n                this.createTicks(group);\n            }\n        },\n\n        getActualTickSize: function() {\n            var options = this.options;\n            var tickSize = 0;\n\n            if (options.majorTicks.visible && options.minorTicks.visible) {\n                tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n            } else if (options.majorTicks.visible) {\n                tickSize = options.majorTicks.size;\n            } else if (options.minorTicks.visible) {\n                tickSize = options.minorTicks.size;\n            }\n\n            return tickSize;\n        },\n\n        createBackground: function() {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var background = options.background;\n\n            if (background) {\n                this._backgroundPath = Path.fromRect(box.toRect(), {\n                    fill: {\n                        color: background\n                    },\n                    stroke: null\n                });\n\n                this.visual.append(this._backgroundPath);\n            }\n        },\n\n        createPlotBands: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var plotBands = options.plotBands || [];\n            var vertical = options.vertical;\n            var plotArea = this.plotArea;\n\n            if (plotBands.length === 0) {\n                return;\n            }\n\n            var group = this._plotbandGroup = new Group({\n                zIndex: -1\n            });\n\n            var altAxis = grep(this.pane.axes, function (axis) { return axis.options.vertical !== this$1$1.options.vertical; })[0];\n\n            for (var idx = 0; idx < plotBands.length; idx++) {\n                var item = plotBands[idx];\n                var slotX = (void 0), slotY = (void 0);\n                var labelOptions = item.label;\n                var label = (void 0);\n\n                if (vertical) {\n                    slotX = (altAxis || plotArea.axisX).lineBox();\n                    slotY = this$1$1.getSlot(item.from, item.to, true);\n                } else {\n                    slotX = this$1$1.getSlot(item.from, item.to, true);\n                    slotY = (altAxis || plotArea.axisY).lineBox();\n                }\n\n                if (labelOptions) {\n                    labelOptions.vAlign = labelOptions.position || LEFT;\n                    label = this$1$1.createPlotBandLabel(\n                        labelOptions,\n                        item,\n                        new Box(\n                            slotX.x1,\n                            slotY.y1,\n                            slotX.x2,\n                            slotY.y2\n                        )\n\n                    );\n                }\n\n                if (slotX.width() !== 0 && slotY.height() !== 0) {\n                    var bandRect = new Rect(\n                        [ slotX.x1, slotY.y1 ],\n                        [ slotX.width(), slotY.height() ]\n                    );\n\n                    var path = Path.fromRect(bandRect, {\n                        fill: {\n                            color: item.color,\n                            opacity: item.opacity\n                        },\n                        stroke: null\n                    });\n\n                    group.append(path);\n                    if (label) {\n                        group.append(label);\n                    }\n                }\n            }\n\n            this.appendVisual(group);\n        },\n\n        createPlotBandLabel: function(label, item, box) {\n\n            if (label.visible === false) {\n                return null;\n            }\n\n            var text = label.text;\n            var textbox;\n\n            if (defined(label) && label.visible) {\n                var labelTemplate = getTemplate(label);\n                if (labelTemplate) {\n                    text = labelTemplate({ text: text, item: item });\n                } else if (label.format) {\n                    text = this.chartService.format.auto(label.format, text);\n                }\n\n                if (!label.color) {\n                    label.color = this.options.labels.color;\n                }\n            }\n\n            textbox = new TextBox(text, label);\n            textbox.reflow(box);\n            textbox.renderVisual();\n\n            return textbox.visual;\n        },\n\n        createGridLines: function(altAxis) {\n            var options = this.options;\n            var minorGridLines = options.minorGridLines;\n            var majorGridLines = options.majorGridLines;\n            var minorUnit = options.minorUnit;\n            var vertical = options.vertical;\n            var axisLineVisible = altAxis.options.line.visible;\n            var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n            var lineBox = altAxis.lineBox();\n            var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n            var lineOptions = {\n                lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n                lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n                vertical: vertical\n            };\n            var majorTicks = [];\n\n            var container = this.gridLinesVisual();\n\n            function render(tickPositions, gridLine, skipUnit) {\n                var count = tickPositions.length;\n                var step = Math.max(1, gridLine.step);\n\n                if (gridLine.visible) {\n                    for (var i = gridLine.skip; i < count; i += step) {\n                        var pos = round(tickPositions[i]);\n                        if (!inArray(pos, majorTicks)) {\n                            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n                                lineOptions.position = pos;\n                                container.append(createAxisGridLine(lineOptions, gridLine));\n\n                                majorTicks.push(pos);\n                            }\n                        }\n                    }\n                }\n            }\n\n            render(this.getMajorTickPositions(), majorGridLines);\n            render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n\n            return container.children;\n        },\n\n        reflow: function(box) {\n            var ref = this;\n            var options = ref.options;\n            var labels = ref.labels;\n            var title = ref.title;\n            var vertical = options.vertical;\n            var count = labels.length;\n            var sizeFn = vertical ? WIDTH : HEIGHT;\n            var titleSize = title ? title.box[sizeFn]() : 0;\n            var space = this.getActualTickSize() + options.margin + titleSize;\n            var rootBox = (this.getRoot() || {}).box || box;\n            var boxSize = rootBox[sizeFn]();\n            var maxLabelSize = 0;\n\n            for (var i = 0; i < count; i++) {\n                var labelSize = labels[i].box[sizeFn]();\n                if (labelSize + space <= boxSize) {\n                    maxLabelSize = Math.max(maxLabelSize, labelSize);\n                }\n            }\n\n            if (vertical) {\n                this.box = new Box(\n                    box.x1, box.y1,\n                    box.x1 + maxLabelSize + space, box.y2\n                );\n            } else {\n                this.box = new Box(\n                    box.x1, box.y1,\n                    box.x2, box.y1 + maxLabelSize + space\n                );\n            }\n\n            this.arrangeTitle();\n            this.arrangeLabels();\n            this.arrangeNotes();\n        },\n\n        getLabelsTickPositions: function() {\n            return this.getMajorTickPositions();\n        },\n\n        labelTickIndex: function(label) {\n            return label.index;\n        },\n\n        arrangeLabels: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var options = ref.options;\n            var labels = ref.labels;\n            var labelsBetweenTicks = this.labelsBetweenTicks();\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var tickPositions = this.getLabelsTickPositions();\n\n            for (var idx = 0; idx < labels.length; idx++) {\n                var label = labels[idx];\n                var tickIx = this$1$1.labelTickIndex(label);\n                var labelSize = vertical ? label.box.height() : label.box.width();\n                var firstTickPosition = tickPositions[tickIx];\n                var nextTickPosition = tickPositions[tickIx + 1];\n                var positionStart = (void 0), positionEnd = (void 0);\n\n                if (vertical) {\n                    if (labelsBetweenTicks) {\n                        var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n                        positionStart = middle - (labelSize / 2);\n                    } else {\n                        positionStart = firstTickPosition - (labelSize / 2);\n                    }\n\n                    positionEnd = positionStart;\n                } else {\n                    if (labelsBetweenTicks) {\n                        positionStart = firstTickPosition;\n                        positionEnd = nextTickPosition;\n                    } else {\n                        positionStart = firstTickPosition - (labelSize / 2);\n                        positionEnd = positionStart + labelSize;\n                    }\n                }\n\n                this$1$1.positionLabel(label, mirror, positionStart, positionEnd);\n            }\n        },\n\n        positionLabel: function(label, mirror, positionStart, positionEnd) {\n            if (positionEnd === void 0) { positionEnd = positionStart; }\n\n            var options = this.options;\n            var vertical = options.vertical;\n            var lineBox = this.lineBox();\n            var labelOffset = this.getActualTickSize() + options.margin;\n            var labelBox;\n\n            if (vertical) {\n                var labelX = lineBox.x2;\n\n                if (mirror) {\n                    labelX += labelOffset;\n                    label.options.rotationOrigin = LEFT;\n                } else {\n                    labelX -= labelOffset + label.box.width();\n                    label.options.rotationOrigin = RIGHT;\n                }\n\n                labelBox = label.box.move(labelX, positionStart);\n            } else {\n                var labelY = lineBox.y1;\n\n                if (mirror) {\n                    labelY -= labelOffset + label.box.height();\n                    label.options.rotationOrigin = BOTTOM;\n                } else {\n                    labelY += labelOffset;\n                    label.options.rotationOrigin = TOP;\n                }\n\n                labelBox = new Box(\n                    positionStart, labelY,\n                    positionEnd, labelY + label.box.height()\n                );\n            }\n\n            label.reflow(labelBox);\n        },\n\n        autoRotateLabelAngle: function(labelBox, slotWidth) {\n            if (labelBox.width() < slotWidth) {\n                return 0;\n            }\n\n            if (labelBox.height() > slotWidth) {\n                return -90;\n            }\n\n            return -45;\n        },\n\n        autoRotateLabels: function() {\n            var this$1$1 = this;\n\n            if (!this.options.autoRotateLabels || this.options.vertical) {\n                return false;\n            }\n\n            var tickPositions = this.getMajorTickPositions();\n            var labels = this.labels;\n            var limit = Math.min(labels.length, tickPositions.length - 1);\n            var angle = 0;\n\n            for (var idx = 0; idx < limit; idx++) {\n                var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n                var labelBox = labels[idx].box;\n                var labelAngle = this$1$1.autoRotateLabelAngle(labelBox, width);\n\n                if (labelAngle !== 0) {\n                    angle = labelAngle;\n                }\n\n                if (angle === -90) {\n                    break;\n                }\n            }\n\n            if (angle !== 0) {\n                for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n                    labels[idx$1].options.rotation = angle;\n                    labels[idx$1].reflow(new Box());\n                }\n\n                return true;\n            }\n        },\n\n        arrangeTitle: function() {\n            var ref = this;\n            var options = ref.options;\n            var title = ref.title;\n            var mirror = options.labels.mirror;\n            var vertical = options.vertical;\n\n            if (title) {\n                if (vertical) {\n                    title.options.align = mirror ? RIGHT : LEFT;\n                    title.options.vAlign = title.options.position;\n                } else {\n                    title.options.align = title.options.position;\n                    title.options.vAlign = mirror ? TOP : BOTTOM;\n                }\n\n                title.reflow(this.box);\n            }\n        },\n\n        arrangeNotes: function() {\n            var this$1$1 = this;\n\n            for (var idx = 0; idx < this.notes.length; idx++) {\n                var item = this$1$1.notes[idx];\n                var value = item.options.value;\n                var slot = (void 0);\n\n                if (defined(value)) {\n                    if (this$1$1.shouldRenderNote(value)) {\n                        item.show();\n                    } else {\n                        item.hide();\n                    }\n\n                    slot = this$1$1.noteSlot(value);\n                } else {\n                    item.hide();\n                }\n\n                item.reflow(slot || this$1$1.lineBox());\n            }\n        },\n\n        noteSlot: function(value) {\n            return this.getSlot(value);\n        },\n\n        alignTo: function(secondAxis) {\n            var lineBox = secondAxis.lineBox();\n            var vertical = this.options.vertical;\n            var pos = vertical ? Y : X;\n\n            this.box.snapTo(lineBox, pos);\n            if (vertical) {\n                this.box.shrink(0, this.lineBox().height() - lineBox.height());\n            } else {\n                this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n            }\n            this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n            this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n        },\n\n        axisLabelText: function(value, options, context) {\n            var this$1$1 = this;\n\n            var text;\n            var tmpl = getTemplate(options);\n            var defaultText = function () {\n                if (!options.format) {\n                    return value;\n                }\n\n                return this$1$1.chartService.format.localeAuto(\n                    options.format, [ value ], options.culture\n                );\n            };\n\n            if (tmpl) {\n                var templateContext = $.extend({}, context, {\n                    get text() { return defaultText(); },\n                    value: value,\n                    format: options.format,\n                    culture: options.culture\n                });\n\n                text = tmpl(templateContext);\n            } else {\n                text = defaultText();\n            }\n\n            return text;\n        },\n\n        slot: function(from , to, limit) {\n            var slot = this.getSlot(from, to, limit);\n            if (slot) {\n                return slot.toRect();\n            }\n        },\n\n        contentBox: function() {\n            var box = this.box.clone();\n            var labels = this.labels;\n            if (labels.length) {\n                var axis = this.options.vertical ? Y : X;\n                if (this.chartService.isPannable(axis)) {\n                    var offset = this.maxLabelOffset();\n                    box[axis + 1] -= offset.start;\n                    box[axis + 2] += offset.end;\n                } else {\n                    if (labels[0].options.visible) {\n                        box.wrap(labels[0].box);\n                    }\n                    var lastLabel = labels[labels.length - 1];\n                    if (lastLabel.options.visible) {\n                        box.wrap(lastLabel.box);\n                    }\n                }\n            }\n\n            return box;\n        },\n\n        maxLabelOffset: function() {\n            var this$1$1 = this;\n\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var labelsBetweenTicks = this.labelsBetweenTicks();\n            var tickPositions = this.getLabelsTickPositions();\n            var offsetField = vertical ? Y : X;\n            var labels = this.labels;\n            var startPosition = reverse ? 1 : 0;\n            var endPosition = reverse ? 0 : 1;\n            var maxStartOffset = 0;\n            var maxEndOffset = 0;\n\n            for (var idx = 0; idx < labels.length; idx++) {\n                var label = labels[idx];\n                var tickIx = this$1$1.labelTickIndex(label);\n                var startTick = (void 0), endTick = (void 0);\n\n                if (labelsBetweenTicks) {\n                    startTick = tickPositions[tickIx + startPosition];\n                    endTick = tickPositions[tickIx + endPosition];\n                } else {\n                    startTick = endTick = tickPositions[tickIx];\n                }\n\n                maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n                maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n            }\n\n            return {\n                start: maxStartOffset,\n                end: maxEndOffset\n            };\n        },\n\n        limitRange: function(from, to, min, max, offset) {\n            var options = this.options;\n\n            if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\n                return null;\n            }\n\n            if ((to < min && offset > 0) || (max < from && offset < 0)) {\n                return {\n                    min: from,\n                    max: to\n                };\n            }\n\n            var rangeSize = to - from;\n            var minValue = from;\n            var maxValue = to;\n\n            if (from < min && offset < 0) {\n                minValue = limitValue(from, min, max);\n                maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n            } else if (to > max && offset > 0) {\n                maxValue = limitValue(to, min, max);\n                minValue = limitValue(to - rangeSize, min, max - rangeSize);\n            }\n\n            return {\n                min: minValue,\n                max: maxValue\n            };\n        },\n\n        valueRange: function() {\n            return {\n                min: this.seriesMin,\n                max: this.seriesMax\n            };\n        },\n\n        lineDir: function() {\n            /*\n             * Axis line direction:\n             *   * Vertical: up.\n             *   * Horizontal: right.\n             */\n\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n        },\n\n        lineInfo: function() {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var lineBox = this.lineBox();\n            var lineSize = vertical ? lineBox.height() : lineBox.width();\n            var axis = vertical ? Y : X;\n            var axisDir = this.lineDir();\n            var startEdge = axisDir === 1 ? 1 : 2;\n            var axisOrigin = axis + startEdge.toString();\n            var lineStart = lineBox[axisOrigin];\n\n            return {\n                axis: axis,\n                axisOrigin: axisOrigin,\n                axisDir: axisDir,\n                lineBox: lineBox,\n                lineSize: lineSize,\n                lineStart: lineStart\n            };\n        },\n\n        pointOffset: function(point) {\n            var ref = this.lineInfo();\n            var axis = ref.axis;\n            var axisDir = ref.axisDir;\n            var axisOrigin = ref.axisOrigin;\n            var lineBox = ref.lineBox;\n            var lineSize = ref.lineSize;\n            var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n            var offset = relative / lineSize;\n\n            return offset;\n        },\n\n        scaleToDelta: function(rawScale, range) {\n            // Scale >= 1 would result in axis range of 0.\n            // Scale <= -1 would reverse the scale direction.\n            var MAX_SCALE = 0.999;\n            var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n\n            var delta;\n            if (scale > 0) {\n                delta = range * Math.min(1, scale);\n            } else {\n                delta = range - (range / (1 + scale));\n            }\n\n            return delta;\n        },\n\n        labelsBetweenTicks: function() {\n            return !this.options.justified;\n        },\n\n        prepareUserOptions: function() {\n        }\n    });\n\n    setDefaultOptions(Axis, {\n        labels: {\n            visible: true,\n            rotation: 0,\n            mirror: false,\n            step: 1,\n            skip: 0\n        },\n        line: {\n            width: 1,\n            color: BLACK,\n            visible: true\n        },\n        title: {\n            visible: true,\n            position: CENTER\n        },\n        majorTicks: {\n            align: OUTSIDE,\n            size: 4,\n            skip: 0,\n            step: 1\n        },\n        minorTicks: {\n            align: OUTSIDE,\n            size: 3,\n            skip: 0,\n            step: 1\n        },\n        axisCrossingValue: 0,\n        majorTickType: OUTSIDE,\n        minorTickType: NONE,\n        majorGridLines: {\n            skip: 0,\n            step: 1\n        },\n        minorGridLines: {\n            visible: false,\n            width: 1,\n            color: BLACK,\n            skip: 0,\n            step: 1\n        },\n        // TODO: Move to line or labels options\n        margin: 5,\n        visible: true,\n        reverse: false,\n        justified: true,\n        notes: {\n            label: {\n                text: \"\"\n            }\n        },\n\n        _alignLines: true,\n        _deferLabels: false\n    });\n\n    var MILLISECONDS = \"milliseconds\";\n    var SECONDS = \"seconds\";\n    var MINUTES = \"minutes\";\n    var HOURS = \"hours\";\n    var DAYS = \"days\";\n    var WEEKS = \"weeks\";\n    var MONTHS = \"months\";\n    var YEARS = \"years\";\n\n    var TIME_PER_MILLISECOND = 1;\n    var TIME_PER_SECOND = 1000;\n    var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;\n    var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;\n    var TIME_PER_DAY = 24 * TIME_PER_HOUR;\n    var TIME_PER_WEEK = 7 * TIME_PER_DAY;\n    var TIME_PER_MONTH = 31 * TIME_PER_DAY;\n    var TIME_PER_YEAR = 365 * TIME_PER_DAY;\n    var TIME_PER_UNIT = {\n        \"years\": TIME_PER_YEAR,\n        \"months\": TIME_PER_MONTH,\n        \"weeks\": TIME_PER_WEEK,\n        \"days\": TIME_PER_DAY,\n        \"hours\": TIME_PER_HOUR,\n        \"minutes\": TIME_PER_MINUTE,\n        \"seconds\": TIME_PER_SECOND,\n        \"milliseconds\": TIME_PER_MILLISECOND\n    };\n\n    function absoluteDateDiff(a, b) {\n        var diff = a.getTime() - b;\n        var offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();\n\n        return diff - (offsetDiff * TIME_PER_MINUTE);\n    }\n\n    function addTicks(date, ticks) {\n        return new Date(date.getTime() + ticks);\n    }\n\n    function toDate(value) {\n        var result;\n\n        if (value instanceof Date) {\n            result = value;\n        } else if (value) {\n            result = new Date(value);\n        }\n\n        return result;\n    }\n\n    function startOfWeek(date, weekStartDay) {\n        if (weekStartDay === void 0) { weekStartDay = 0; }\n\n        var daysToSubtract = 0;\n        var day = date.getDay();\n\n        if (!isNaN(day)) {\n            while (day !== weekStartDay) {\n                if (day === 0) {\n                    day = 6;\n                } else {\n                    day--;\n                }\n\n                daysToSubtract++;\n            }\n        }\n\n        return addTicks(date, -daysToSubtract * TIME_PER_DAY);\n    }\n\n    function adjustDST(date, hours) {\n        if (hours === 0 && date.getHours() === 23) {\n            date.setHours(date.getHours() + 2);\n            return true;\n        }\n\n        return false;\n    }\n\n    function addHours(date, hours) {\n        var roundedDate = new Date(date);\n\n        roundedDate.setMinutes(0, 0, 0);\n\n        var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;\n\n        return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);\n    }\n\n    function addDuration(dateValue, value, unit, weekStartDay) {\n        var result = dateValue;\n\n        if (dateValue) {\n            var date = toDate(dateValue);\n            var hours = date.getHours();\n\n            if (unit === YEARS) {\n                result = new Date(date.getFullYear() + value, 0, 1);\n                adjustDST(result, 0);\n            } else if (unit === MONTHS) {\n                result = new Date(date.getFullYear(), date.getMonth() + value, 1);\n                adjustDST(result, hours);\n            } else if (unit === WEEKS) {\n                result = addDuration(startOfWeek(date, weekStartDay), value * 7, DAYS);\n                adjustDST(result, hours);\n            } else if (unit === DAYS) {\n                result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value);\n                adjustDST(result, hours);\n            } else if (unit === HOURS) {\n                result = addHours(date, value);\n            } else if (unit === MINUTES) {\n                result = addTicks(date, value * TIME_PER_MINUTE);\n\n                if (result.getSeconds() > 0) {\n                    result.setSeconds(0);\n                }\n            } else if (unit === SECONDS) {\n                result = addTicks(date, value * TIME_PER_SECOND);\n            } else if (unit === MILLISECONDS) {\n                result = addTicks(date, value);\n            }\n\n            if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {\n                result.setMilliseconds(0);\n            }\n        }\n\n        return result;\n    }\n\n    function floorDate(date, unit, weekStartDay) {\n        return addDuration(toDate(date), 0, unit, weekStartDay);\n    }\n\n    function ceilDate(dateValue, unit, weekStartDay) {\n        var date = toDate(dateValue);\n\n        if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {\n            return date;\n        }\n\n        return addDuration(date, 1, unit, weekStartDay);\n    }\n\n    function dateComparer(a, b) {\n        if (a && b) {\n            return a.getTime() - b.getTime();\n        }\n\n        return -1;\n    }\n\n    function dateDiff(a, b) {\n        return a.getTime() - b;\n    }\n\n    function toTime(value) {\n        if (isArray(value)) {\n            var result = [];\n            for (var idx = 0; idx < value.length; idx++) {\n                result.push(toTime(value[idx]));\n            }\n\n            return result;\n        } else if (value) {\n            return toDate(value).getTime();\n        }\n    }\n\n    function dateEquals(a, b) {\n        if (a && b) {\n            return toTime(a) === toTime(b);\n        }\n\n        return a === b;\n    }\n\n    function timeIndex(date, start, baseUnit) {\n        return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n    }\n\n    function dateIndex(value, start, baseUnit, baseUnitStep) {\n        var date = toDate(value);\n        var startDate = toDate(start);\n        var index;\n\n        if (baseUnit === MONTHS) {\n            index = (date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12) +\n                timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n        } else if (baseUnit === YEARS) {\n            index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;\n        } else if (baseUnit === DAYS || baseUnit === WEEKS) {\n            index = timeIndex(date, startDate, baseUnit);\n        } else {\n            index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n        }\n\n        return index / baseUnitStep;\n    }\n\n    function duration(a, b, unit) {\n        var diff;\n\n        if (unit === YEARS) {\n            diff = b.getFullYear() - a.getFullYear();\n        } else if (unit === MONTHS) {\n            diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();\n        } else if (unit === DAYS) {\n            diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);\n        } else {\n            diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);\n        }\n\n        return diff;\n    }\n\n    function lteDateIndex(date, sortedDates) {\n        var low = 0;\n        var high = sortedDates.length - 1;\n        var index;\n\n        while (low <= high) {\n            index = Math.floor((low + high) / 2);\n            var currentDate = sortedDates[index];\n\n            if (currentDate < date) {\n                low = index + 1;\n                continue;\n            }\n\n            if (currentDate > date) {\n                high = index - 1;\n                continue;\n            }\n\n            while (dateEquals(sortedDates[index - 1], date)) {\n                index--;\n            }\n\n            return index;\n        }\n\n        if (sortedDates[index] <= date) {\n            return index;\n        }\n\n        return index - 1;\n    }\n\n    function parseDate(intlService, date) {\n        var result;\n        if (isString(date)) {\n            result = intlService.parseDate(date) || toDate(date);\n        } else {\n            result = toDate(date);\n        }\n        return result;\n    }\n\n    function parseDates(intlService, dates) {\n        if (isArray(dates)) {\n            var result = [];\n            for (var idx = 0; idx < dates.length; idx++) {\n                result.push(parseDate(intlService, dates[idx]));\n            }\n\n            return result;\n        }\n\n        return parseDate(intlService, dates);\n    }\n\n    function firstDay(options, intlService) {\n        if (isNumber(options.weekStartDay)) {\n            return options.weekStartDay;\n        }\n\n        if (intlService && intlService.firstDay) {\n            return intlService.firstDay();\n        }\n\n        return 0;\n    }\n\n    var MIN_CATEGORY_POINTS_RANGE = 0.01;\n    var MIN_CATEGORY_RANGE = 0.1;\n\n    function indexOf(value, arr) {\n        if (value instanceof Date) {\n            var length = arr.length;\n            for (var idx = 0; idx < length; idx++) {\n                if (dateEquals(arr[idx], value)) {\n                    return idx;\n                }\n            }\n\n            return -1;\n        }\n\n        return arr.indexOf(value);\n    }\n\n    var CategoryAxis = Axis.extend({\n        initFields: function() {\n            this._ticks = {};\n        },\n\n        categoriesHash: function() {\n            return \"\";\n        },\n\n        clone: function() {\n            var copy = new CategoryAxis($.extend({}, this.options, {\n                categories: this.options.srcCategories\n            }), this.chartService);\n            copy.createLabels();\n\n            return copy;\n        },\n\n        initUserOptions: function(options) {\n            var categories = options.categories || [];\n            var definedMin = defined(options.min);\n            var definedMax = defined(options.max);\n            options.srcCategories = options.categories = categories;\n\n            if ((definedMin || definedMax) && categories.length) {\n                var min = definedMin ? Math.floor(options.min) : 0;\n                var max;\n\n                if (definedMax) {\n                    max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n                } else {\n                    max = categories.length;\n                }\n\n                options.categories = options.categories.slice(min, max);\n            }\n\n            return options;\n        },\n\n        rangeIndices: function() {\n            var options = this.options;\n            var length = options.categories.length || 1;\n            var min = isNumber(options.min) ? options.min % 1 : 0;\n            var max;\n\n            if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n                max = length - (1 - options.max % 1);\n            } else {\n                max = length - (options.justified ? 1 : 0);\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        range: function() {\n            var options = this.options;\n            var min = isNumber(options.min) ? options.min : 0;\n            var max = isNumber(options.max) ? options.max : this.totalRange().max;\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        roundedRange: function() {\n            return this.range();\n        },\n\n        totalRange: function() {\n            var options = this.options;\n            return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };\n        },\n\n        scaleOptions: function() {\n            var ref = this.rangeIndices();\n            var min = ref.min;\n            var max = ref.max;\n            var lineBox = this.lineBox();\n            var size = this.options.vertical ? lineBox.height() : lineBox.width();\n            var scale = size / ((max - min) || 1);\n\n            return {\n                scale: scale * (this.options.reverse ? -1 : 1),\n                box: lineBox,\n                min: min,\n                max: max\n            };\n        },\n\n        arrangeLabels: function() {\n            Axis.fn.arrangeLabels.call(this);\n            this.hideOutOfRangeLabels();\n        },\n\n        hideOutOfRangeLabels: function() {\n            var ref = this;\n            var box = ref.box;\n            var labels = ref.labels;\n\n            if (labels.length > 0) {\n                var valueAxis = this.options.vertical ? Y : X;\n                var start = box[valueAxis + 1];\n                var end = box[valueAxis + 2];\n                var firstLabel = labels[0];\n                var lastLabel = last(labels);\n\n                if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n                    firstLabel.options.visible = false;\n                }\n                if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n                    lastLabel.options.visible = false;\n                }\n            }\n        },\n\n        getMajorTickPositions: function() {\n            return this.getTicks().majorTicks;\n        },\n\n        getMinorTickPositions: function() {\n            return this.getTicks().minorTicks;\n        },\n\n        getLabelsTickPositions: function() {\n            return this.getTicks().labelTicks;\n        },\n\n        tickIndices: function(stepSize) {\n            var ref = this.rangeIndices();\n            var min = ref.min;\n            var max = ref.max;\n            var limit = Math.ceil(max);\n            var current = Math.floor(min);\n            var indices = [];\n\n            while (current <= limit) {\n                indices.push(current);\n                current += stepSize;\n            }\n\n            return indices;\n        },\n\n        getTickPositions: function(stepSize) {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var ref$1 = this.scaleOptions();\n            var scale = ref$1.scale;\n            var box = ref$1.box;\n            var min = ref$1.min;\n            var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n            var indices = this.tickIndices(stepSize);\n            var positions = [];\n\n            for (var idx = 0; idx < indices.length; idx++) {\n                positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n            }\n\n            return positions;\n        },\n\n        getTicks: function() {\n            var options = this.options;\n            var cache = this._ticks;\n            var range = this.rangeIndices();\n            var lineBox = this.lineBox();\n            var hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n\n            if (cache._hash !== hash) {\n                var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n                cache._hash = hash;\n                cache.labelTicks = this.getTickPositions(1);\n                cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n                cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n            }\n\n            return cache;\n        },\n\n        filterOutOfRangePositions: function(positions, lineBox) {\n            if (!positions.length) {\n                return positions;\n            }\n\n            var axis = this.options.vertical ? Y : X;\n            var inRange = function (position) { return lineBox[axis + 1] <= position && position <= lineBox[axis + 2]; };\n\n            var end = positions.length - 1;\n            var startIndex = 0;\n            while (!inRange(positions[startIndex]) && startIndex <= end) {\n                startIndex++;\n            }\n\n            var endIndex = end;\n\n            while (!inRange(positions[endIndex]) && endIndex >= 0) {\n                endIndex--;\n            }\n\n            return positions.slice(startIndex, endIndex + 1);\n        },\n\n        lineInfo: function() {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var lineBox = this.lineBox();\n            var lineSize = vertical ? lineBox.height() : lineBox.width();\n            var axis = vertical ? Y : X;\n            var axisDir = reverse ? -1 : 1;\n            var startEdge = axisDir === 1 ? 1 : 2;\n            var axisOrigin = axis + startEdge.toString();\n            var lineStart = lineBox[axisOrigin];\n\n            return {\n                axis: axis,\n                axisOrigin: axisOrigin,\n                axisDir: axisDir,\n                lineBox: lineBox,\n                lineSize: lineSize,\n                lineStart: lineStart\n            };\n        },\n\n        lineDir: function() {\n            /*\n             *  Category axis line direction:\n             *    * Vertical: down.\n             *    * Horizontal: right.\n             */\n\n            var ref = this.options;\n            var reverse = ref.reverse;\n            return reverse ? -1 : 1;\n        },\n\n        getSlot: function(from, to, limit) {\n            var options = this.options;\n            var reverse = options.reverse;\n            var justified = options.justified;\n            var ref = this.scaleOptions();\n            var scale = ref.scale;\n            var box = ref.box;\n            var min = ref.min;\n            var ref$1 = this.lineInfo();\n            var valueAxis = ref$1.axis;\n            var lineStart = ref$1.lineStart;\n\n            var slotBox = box.clone();\n            var singleSlot = !defined(to);\n\n            var start = valueOrDefault(from, 0);\n            var end = valueOrDefault(to, start);\n            end = Math.max(end - 1, start);\n\n            // Fixes transient bug caused by iOS 6.0 JIT\n            // (one can never be too sure)\n            end = Math.max(start, end);\n\n            var p1 = lineStart + (start - min) * scale;\n            var p2 = lineStart + (end + 1 - min) * scale;\n\n            if (singleSlot && justified) {\n                p2 = p1;\n            }\n\n            if (limit) {\n                p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n                p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n            }\n\n            slotBox[valueAxis + 1] = reverse ? p2 : p1;\n            slotBox[valueAxis + 2] = reverse ? p1 : p2;\n\n            return slotBox;\n        },\n\n        limitSlot: function(slot) {\n            var vertical = this.options.vertical;\n            var valueAxis = vertical ? Y : X;\n            var lineBox = this.lineBox();\n            var limittedSlot = slot.clone();\n\n            limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n            limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n\n            return limittedSlot;\n        },\n\n        slot: function(from, to, limit) {\n            var min = Math.floor(this.options.min || 0);\n            var start = from;\n            var end = to;\n\n            if (typeof start === \"string\") {\n                start = this.categoryIndex(start);\n            } else if (isNumber(start)) {\n                start -= min;\n            }\n\n            if (typeof end === \"string\") {\n                end = this.categoryIndex(end);\n            } else if (isNumber(end)) {\n                end -= min;\n            }\n\n            return Axis.fn.slot.call(this, start, end, limit);\n        },\n\n        pointCategoryIndex: function(point) {\n            var ref = this.options;\n            var reverse = ref.reverse;\n            var justified = ref.justified;\n            var vertical = ref.vertical;\n            var valueAxis = vertical ? Y : X;\n            var ref$1 = this.scaleOptions();\n            var scale = ref$1.scale;\n            var box = ref$1.box;\n            var min = ref$1.min;\n            var max = ref$1.max;\n            var startValue = reverse ? max : min;\n            var lineStart = box[valueAxis + 1];\n            var lineEnd = box[valueAxis + 2];\n            var pos = point[valueAxis];\n\n            if (pos < lineStart || pos > lineEnd) {\n                return null;\n            }\n\n            var value = startValue + (pos - lineStart) / scale;\n            var diff = value % 1;\n\n            if (justified) {\n                value = Math.round(value);\n            } else if (diff === 0 && value > 0) {\n                value--;\n            }\n\n            return Math.floor(value);\n        },\n\n        getCategory: function(point) {\n            var index = this.pointCategoryIndex(point);\n\n            if (index === null) {\n                return null;\n            }\n\n            return this.options.categories[index];\n        },\n\n        categoryIndex: function(value) {\n            return this.totalIndex(value) - Math.floor(this.options.min || 0);\n        },\n\n        categoryAt: function(index, total) {\n            var options = this.options;\n\n            return (total ? options.srcCategories : options.categories)[index];\n        },\n\n        categoriesCount: function() {\n            return (this.options.categories || []).length;\n        },\n\n        translateRange: function(delta) {\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var size = options.vertical ? lineBox.height() : lineBox.width();\n            var range = options.categories.length;\n            var scale = size / range;\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            return {\n                min: offset,\n                max: range + offset\n            };\n        },\n\n        scaleRange: function(scale, cursor) {\n            var position = Math.abs(this.pointOffset(cursor));\n            var rangeIndices = this.limitedRangeIndices();\n            var range = rangeIndices.max - rangeIndices.min;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = position * delta;\n            var maxDelta = (1 - position) * delta;\n            var min = rangeIndices.min + minDelta;\n            var max = rangeIndices.max - maxDelta;\n\n            if (max - min < MIN_CATEGORY_RANGE) {\n                max = min + MIN_CATEGORY_RANGE;\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        zoomRange: function(scale, cursor) {\n            var ref = this.totalRange();\n            var totalMin = ref.min;\n            var totalMax = ref.max;\n            var range = this.scaleRange(scale, cursor);\n\n            return {\n                min: limitValue(range.min, totalMin, totalMax),\n                max: limitValue(range.max, totalMin, totalMax)\n            };\n        },\n\n        labelsCount: function() {\n            var labelsRange = this.labelsRange();\n\n            return labelsRange.max - labelsRange.min;\n        },\n\n        labelsRange: function() {\n            var options = this.options;\n            var justified = options.justified;\n            var labelOptions = options.labels;\n            var ref = this.limitedRangeIndices(true);\n            var min = ref.min;\n            var max = ref.max;\n            var start = Math.floor(min);\n\n            if (!justified) {\n                min = Math.floor(min);\n                max = Math.ceil(max);\n            } else {\n                min = Math.ceil(min);\n                max = Math.floor(max);\n            }\n\n            var skip;\n\n            if (min > labelOptions.skip) {\n                skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n            } else {\n                skip = labelOptions.skip;\n            }\n\n            return {\n                min: skip - start,\n                max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n            };\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            var options = this.options;\n            var dataItem = options.dataItems ? options.dataItems[index] : null;\n            var category = valueOrDefault(options.categories[index], \"\");\n\n            labelContext.dataItem = dataItem;\n            var text = this.axisLabelText(category, labelOptions, labelContext);\n\n            return new AxisLabel(category, text, index, dataItem, labelOptions);\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.limitedRangeIndices();\n\n            return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n        },\n\n        noteSlot: function(value) {\n            var options = this.options;\n            var index = value - Math.floor(options.min || 0);\n            return this.getSlot(index);\n        },\n\n        arrangeNotes: function() {\n            Axis.fn.arrangeNotes.call(this);\n            this.hideOutOfRangeNotes();\n        },\n\n        hideOutOfRangeNotes: function() {\n            var ref = this;\n            var notes = ref.notes;\n            var box = ref.box;\n            if (notes && notes.length) {\n                var valueAxis = this.options.vertical ? Y : X;\n                var start = box[valueAxis + 1];\n                var end = box[valueAxis + 2];\n\n                for (var idx = 0; idx < notes.length; idx++) {\n                    var note = notes[idx];\n                    if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n                        note.hide();\n                    }\n                }\n            }\n        },\n\n        pan: function(delta) {\n            var range = this.limitedRangeIndices(true);\n            var ref = this.scaleOptions();\n            var scale = ref.scale;\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n            var totalRange = this.totalRange();\n            var min = range.min + offset;\n            var max = range.max + offset;\n\n            return this.limitRange(min, max, 0, totalRange.max, offset);\n        },\n\n        pointsRange: function(start, end) {\n            var ref = this.options;\n            var reverse = ref.reverse;\n            var vertical = ref.vertical;\n            var valueAxis = vertical ? Y : X;\n            var range = this.limitedRangeIndices(true);\n            var ref$1 = this.scaleOptions();\n            var scale = ref$1.scale;\n            var box = ref$1.box;\n            var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n\n            var diffStart = start[valueAxis] - lineStart;\n            var diffEnd = end[valueAxis] - lineStart;\n\n            var min = range.min + diffStart / scale;\n            var max = range.min + diffEnd / scale;\n            var rangeMin = Math.min(min, max);\n            var rangeMax = Math.max(min, max);\n\n            if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n                return {\n                    min: rangeMin,\n                    max: rangeMax\n                };\n            }\n        },\n\n        valueRange: function() {\n            return this.range();\n        },\n\n        totalIndex: function(value) {\n            var options = this.options;\n            var index = this._categoriesMap ?\n                this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n\n            return index;\n        },\n\n        currentRangeIndices: function() {\n            var options = this.options;\n            var min = 0;\n\n            if (isNumber(options.min)) {\n                min = Math.floor(options.min);\n            }\n\n            var max;\n            if (isNumber(options.max)) {\n                max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n            } else {\n                max = this.totalCount() - 1;\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        limitedRangeIndices: function(totalLimit) {\n            var options = this.options;\n            var min = isNumber(options.min) ? options.min : 0;\n            var max;\n\n            if (isNumber(options.max)) {\n                max = options.max;\n            } else if (isNumber(options.min)) {\n                max = min + options.categories.length;\n            } else {\n                max = this.totalRange().max || 1;\n            }\n\n            if (totalLimit) {\n                var totalRange = this.totalRange();\n                min = limitValue(min, 0, totalRange.max);\n                max = limitValue(max, 0, totalRange.max);\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        totalRangeIndices: function() {\n            return {\n                min: 0,\n                max: this.totalRange().max || 1\n            };\n        },\n\n        indexCategories: function() {\n            if (!this._categoriesMap) {\n                var map$$1 = this._categoriesMap = new HashMap();\n                var srcCategories = this.options.srcCategories;\n                for (var idx = 0; idx < srcCategories.length; idx++) {\n                    map$$1.set(srcCategories[idx], idx);\n                }\n            }\n        },\n\n        totalCount: function() {\n            return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n        }\n    });\n\n    setDefaultOptions(CategoryAxis, {\n        type: \"category\",\n        vertical: false,\n        majorGridLines: {\n            visible: false,\n            width: 1,\n            color: BLACK\n        },\n        labels: {\n            zIndex: 1\n        },\n        justified: false,\n        _deferLabels: true\n    });\n\n    var COORDINATE_LIMIT = 300000;\n\n    var DateLabelFormats = {\n        milliseconds: \"HH:mm:ss.fff\",\n        seconds: \"HH:mm:ss\",\n        minutes: \"HH:mm\",\n        hours: \"HH:mm\",\n        days: \"M/d\",\n        weeks: \"M/d\",\n        months: \"MMM 'yy\",\n        years: \"yyyy\"\n    };\n\n    var ZERO_THRESHOLD = 0.2;\n\n    var AUTO = \"auto\";\n    var BASE_UNITS = [\n        MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS\n    ];\n    var FIT = \"fit\";\n\n    function categoryRange(categories, clearCache) {\n        if (clearCache) {\n            categories._range = undefined;\n        }\n\n        var range = categories._range;\n        if (!range) {\n            range = categories._range = sparseArrayLimits(categories);\n            range.min = toDate(range.min);\n            range.max = toDate(range.max);\n        }\n\n        return range;\n    }\n\n    var EmptyDateRange = Class.extend({\n        init: function(options) {\n            this.options = options;\n        },\n\n        displayIndices: function() {\n            return {\n                min: 0,\n                max: 1\n            };\n        },\n\n        displayRange: function() {\n            return {};\n        },\n\n        total: function() {\n            return {};\n        },\n\n        valueRange: function() {\n            return {};\n        },\n\n        valueIndex: function() {\n            return -1;\n        },\n\n        values: function() {\n            return [];\n        },\n\n        totalIndex: function() {\n            return -1;\n        },\n\n        valuesCount: function() {\n            return 0;\n        },\n\n        totalCount: function() {\n            return 0;\n        },\n\n        dateAt: function() {\n            return null;\n        }\n    });\n\n    var DateRange = Class.extend({\n        init: function(start, end, options) {\n            this.options = options;\n            options.baseUnitStep = options.baseUnitStep || 1;\n\n            var roundToBaseUnit = options.roundToBaseUnit;\n            var justified = options.justified;\n\n            this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n            var lowerEnd = this.roundToTotalStep(end);\n            var expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n\n            this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n\n            var min = options.min || start;\n            this.valueStart = this.roundToTotalStep(min);\n            this.displayStart = roundToBaseUnit ? this.valueStart : min;\n\n            var max = options.max;\n            if (!max) {\n                this.valueEnd = lowerEnd;\n                this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n            } else {\n                var next = !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0;\n                this.valueEnd = this.roundToTotalStep(max, false, next);\n                this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n            }\n\n            if (this.valueEnd < this.valueStart) {\n                this.valueEnd = this.valueStart;\n            }\n            if (this.displayEnd <= this.displayStart) {\n                this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n            }\n        },\n\n        displayRange: function() {\n            return {\n                min: this.displayStart,\n                max: this.displayEnd\n            };\n        },\n\n        displayIndices: function() {\n            if (!this._indices) {\n                var options = this.options;\n\n                var baseUnit = options.baseUnit;\n                var baseUnitStep = options.baseUnitStep;\n\n                var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n                var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n\n                this._indices = { min: minIdx, max: maxIdx };\n            }\n\n            return this._indices;\n        },\n\n        total: function() {\n            return {\n                min: this.start,\n                max: this.end\n            };\n        },\n\n        totalCount: function() {\n            var last$$1 = this.totalIndex(this.end);\n\n            return last$$1 + (this.options.justified ? 1 : 0);\n        },\n\n        valueRange: function() {\n            return {\n                min: this.valueStart,\n                max: this.valueEnd\n            };\n        },\n\n        valueIndex: function(value) {\n            var options = this.options;\n            return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n        },\n\n        totalIndex: function(value) {\n            var options = this.options;\n            return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n        },\n\n        dateIndex: function(value) {\n            var options = this.options;\n            return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n        },\n\n        valuesCount: function() {\n            var maxIdx = this.valueIndex(this.valueEnd);\n\n            return maxIdx + 1;\n        },\n\n        values: function() {\n            var values = this._values;\n            if (!values) {\n                var options = this.options;\n                var range = this.valueRange();\n                this._values = values = [];\n\n                for (var date = range.min; date <= range.max;) {\n                    values.push(date);\n                    date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n                }\n            }\n\n            return values;\n        },\n\n        dateAt: function(index, total) {\n            var options = this.options;\n\n            return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n        },\n\n        roundToTotalStep: function(value, upper, next) {\n            var ref = this.options;\n            var baseUnit = ref.baseUnit;\n            var baseUnitStep = ref.baseUnitStep;\n            var weekStartDay = ref.weekStartDay;\n            var start = this.start;\n\n            var step = dateIndex(value, start, baseUnit, baseUnitStep);\n            var roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n\n            if (next) {\n                roundedStep += next;\n            }\n\n            return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n        }\n    });\n\n    function autoBaseUnit(options, startUnit, startStep) {\n        var categoryLimits = categoryRange(options.categories);\n        var span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n        var autoBaseUnitSteps = options.autoBaseUnitSteps;\n        var maxDateGroups = options.maxDateGroups;\n        var autoUnit = options.baseUnit === FIT;\n        var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n        var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n        var units = span / TIME_PER_UNIT[baseUnit];\n        var totalUnits = units;\n        var unitSteps, step, nextStep;\n\n        while (!step || units >= maxDateGroups) {\n            unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n\n            do {\n                nextStep = unitSteps.shift();\n            } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n\n            if (nextStep) {\n                step = nextStep;\n                units = totalUnits / step;\n            } else if (baseUnit === last(BASE_UNITS)) {\n                step = Math.ceil(totalUnits / maxDateGroups);\n                break;\n            } else if (autoUnit) {\n                baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n                totalUnits = span / TIME_PER_UNIT[baseUnit];\n                unitSteps = null;\n            } else {\n                if (units > maxDateGroups) {\n                    step = Math.ceil(totalUnits / maxDateGroups);\n                }\n                break;\n            }\n        }\n\n        options.baseUnitStep = step;\n        options.baseUnit = baseUnit;\n    }\n\n    function defaultBaseUnit(options) {\n        var categories = options.categories;\n        var count = defined(categories) ? categories.length : 0;\n        var minDiff = MAX_VALUE;\n        var lastCategory, unit;\n\n        for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n            var category = categories[categoryIx];\n\n            if (category && lastCategory) {\n                var diff = Math.abs(absoluteDateDiff(category, lastCategory));\n\n                if (diff !== 0) {\n                    minDiff = Math.min(minDiff, diff);\n\n                    if (minDiff >= TIME_PER_YEAR) {\n                        unit = YEARS;\n                    } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n                        unit = MONTHS;\n                    } else if (minDiff >= TIME_PER_WEEK) {\n                        unit = WEEKS;\n                    } else if (minDiff >= TIME_PER_DAY) {\n                        unit = DAYS;\n                    } else if (minDiff >= TIME_PER_HOUR) {\n                        unit = HOURS;\n                    } else if (minDiff >= TIME_PER_MINUTE) {\n                        unit = MINUTES;\n                    } else {\n                        unit = SECONDS;\n                    }\n                }\n            }\n\n            lastCategory = category;\n        }\n\n        options.baseUnit = unit || DAYS;\n    }\n\n    function initUnit(options) {\n        var baseUnit = (options.baseUnit || \"\").toLowerCase();\n        var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n\n        if (useDefault) {\n            defaultBaseUnit(options);\n        }\n\n        if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n            autoBaseUnit(options);\n        }\n\n        return options;\n    }\n\n    var DateCategoryAxis = CategoryAxis.extend({\n        clone: function() {\n            var copy = new DateCategoryAxis($.extend({}, this.options), this.chartService);\n            copy.createLabels();\n\n            return copy;\n        },\n\n        categoriesHash: function() {\n            var start = this.dataRange.total().min;\n            return this.options.baseUnit + this.options.baseUnitStep + start;\n        },\n\n        initUserOptions: function(options) {\n            return options;\n        },\n\n        initFields: function() {\n            CategoryAxis.fn.initFields.call(this);\n\n            var chartService = this.chartService;\n            var intlService = chartService.intl;\n            var options = this.options;\n\n            var categories = options.categories || [];\n            if (!categories._parsed) {\n                categories = parseDates(intlService, categories);\n                categories._parsed = true;\n            }\n\n            options = deepExtend({\n                roundToBaseUnit: true\n            }, options, {\n                categories: categories,\n                min: parseDate(intlService, options.min),\n                max: parseDate(intlService, options.max),\n                weekStartDay: firstDay(options, intlService)\n            });\n\n            if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n                options.roundToBaseUnit = false;\n            }\n\n            options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n            options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n\n            this.options = options;\n            options.srcCategories = categories;\n\n            if (categories.length > 0) {\n                var range = categoryRange(categories, true);\n                var maxDivisions = options.maxDivisions;\n                var safeOptions = initUnit(options);\n\n                var forecast = options._forecast;\n                if (forecast) {\n                    if (forecast.before > 0) {\n                        range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);\n                    }\n\n                    if (forecast.after > 0) {\n                        range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);\n                    }\n                }\n\n                this.dataRange = new DateRange(range.min, range.max, safeOptions);\n\n                if (maxDivisions) {\n                    var dataRange = this.dataRange.displayRange();\n\n                    var divisionOptions = $.extend({}, options, {\n                        justified: true,\n                        roundToBaseUnit: false,\n                        baseUnit: 'fit',\n                        min: dataRange.min,\n                        max: dataRange.max,\n                        maxDateGroups: maxDivisions\n                    });\n\n                    var dataRangeOptions = this.dataRange.options;\n\n                    autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n\n                    this.divisionRange = new DateRange(range.min, range.max, divisionOptions);\n                } else {\n                    this.divisionRange = this.dataRange;\n                }\n\n            } else {\n                options.baseUnit = options.baseUnit || DAYS;\n                this.dataRange = this.divisionRange = new EmptyDateRange(options);\n            }\n\n            this.rangeLabels = [];\n        },\n\n        tickIndices: function(stepSize) {\n            var ref = this;\n            var dataRange = ref.dataRange;\n            var divisionRange = ref.divisionRange;\n            var valuesCount = divisionRange.valuesCount();\n\n            if (!this.options.maxDivisions || !valuesCount) {\n                return CategoryAxis.fn.tickIndices.call(this, stepSize);\n            }\n\n            var indices = [];\n            var values = divisionRange.values();\n            var offset = 0;\n\n            if (!this.options.justified) {\n                values = values.concat(divisionRange.dateAt(valuesCount));\n                offset = 0.5;//align ticks to the center of not justified categories\n            }\n\n            for (var idx = 0; idx < values.length; idx++) {\n                indices.push(dataRange.dateIndex(values[idx]) + offset);\n                if (stepSize !== 1 && idx >= 1) {\n                    var last$$1 = indices.length - 1;\n                    indices.splice(idx, 0, indices[last$$1 - 1] + (indices[last$$1] - indices[last$$1 - 1]) * stepSize);\n                }\n            }\n\n            return indices;\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.range();\n            var categories = this.options.categories || [];\n\n            return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n        },\n\n        parseNoteValue: function(value) {\n            return parseDate(this.chartService.intl, value);\n        },\n\n        noteSlot: function(value) {\n            return this.getSlot(value);\n        },\n\n        translateRange: function(delta) {\n            var options = this.options;\n            var baseUnit = options.baseUnit;\n            var weekStartDay = options.weekStartDay;\n            var vertical = options.vertical;\n            var lineBox = this.lineBox();\n            var size = vertical ? lineBox.height() : lineBox.width();\n            var range = this.range();\n            var scale = size / (range.max - range.min);\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if (range.min && range.max) {\n                var from = addTicks(options.min || range.min, offset);\n                var to = addTicks(options.max || range.max, offset);\n\n                range = {\n                    min: addDuration(from, 0, baseUnit, weekStartDay),\n                    max: addDuration(to, 0, baseUnit, weekStartDay)\n                };\n            }\n\n            return range;\n        },\n\n        labelsRange: function() {\n            return {\n                min: this.options.labels.skip,\n                max: this.divisionRange.valuesCount()\n            };\n        },\n\n        pan: function(delta) {\n            if (this.isEmpty()) {\n                return null;\n            }\n\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var size = options.vertical ? lineBox.height() : lineBox.width();\n            var ref = this.dataRange.displayRange();\n            var min = ref.min;\n            var max = ref.max;\n            var totalLimits = this.dataRange.total();\n            var scale = size / (max - min);\n            var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n            var from = addTicks(min, offset);\n            var to = addTicks(max, offset);\n\n            var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n\n            if (panRange) {\n                panRange.min = toDate(panRange.min);\n                panRange.max = toDate(panRange.max);\n                panRange.baseUnit = options.baseUnit;\n                panRange.baseUnitStep = options.baseUnitStep || 1;\n                panRange.userSetBaseUnit = options.userSetBaseUnit;\n                panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n\n                return panRange;\n            }\n        },\n\n        pointsRange: function(start, end) {\n            if (this.isEmpty()) {\n                return null;\n            }\n\n            var pointsRange = CategoryAxis.fn.pointsRange.call(this, start, end);\n            var datesRange = this.dataRange.displayRange();\n            var indicesRange = this.dataRange.displayIndices();\n            var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n            var options = this.options;\n\n            var min = addTicks(datesRange.min, pointsRange.min * scale);\n            var max = addTicks(datesRange.min, pointsRange.max * scale);\n\n            return {\n                min: min,\n                max: max,\n                baseUnit: options.userSetBaseUnit || options.baseUnit,\n                baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n            };\n        },\n\n        scaleRange: function(scale, cursor) {\n            if (this.isEmpty()) {\n                return {};\n            }\n\n            var options = this.options;\n            var fit = options.userSetBaseUnit === FIT;\n            var totalLimits = this.dataRange.total();\n            var ref = this.dataRange.displayRange();\n            var rangeMin = ref.min;\n            var rangeMax = ref.max;\n\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = rangeMax - rangeMin;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = Math.round(position * delta);\n            var maxDelta = Math.round((1 - position) * delta);\n\n            var ref$1 = this.dataRange.options;\n            var baseUnit = ref$1.baseUnit;\n            var min = new Date(rangeMin.getTime() + minDelta);\n            var max = new Date(rangeMax.getTime() - maxDelta);\n\n            if (fit) {\n                var autoBaseUnitSteps = options.autoBaseUnitSteps;\n                var maxDateGroups = options.maxDateGroups;\n\n                var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n                var rangeDiff = dateDiff(rangeMax, rangeMin);\n                var diff = dateDiff(max, min);\n                var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n                var autoBaseUnitStep, ticks;\n\n                if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n                    baseUnit = BASE_UNITS[baseUnitIndex - 1];\n                    autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n                    ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n                    min = addTicks(rangeMin, ticks);\n                    max = addTicks(rangeMax, -ticks);\n\n                } else if (diff > maxDiff && baseUnit !== YEARS) {\n                    var stepIndex = 0;\n\n                    do {\n                        baseUnitIndex++;\n                        baseUnit = BASE_UNITS[baseUnitIndex];\n                        stepIndex = 0;\n                        ticks = 2 * TIME_PER_UNIT[baseUnit];\n                        do {\n                            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n                            stepIndex++;\n                        } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n                    } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n\n                    ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n                    if (ticks > 0) {\n                        min = addTicks(rangeMin, -ticks);\n                        max = addTicks(rangeMax, ticks);\n                        min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n                        max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n                    }\n                }\n            }\n\n            if (min && max && dateDiff(max, min) > 0) {\n                return {\n                    min: min,\n                    max: max,\n                    baseUnit: options.userSetBaseUnit || options.baseUnit,\n                    baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n                };\n            }\n        },\n\n        zoomRange: function(scale, cursor) {\n            var totalLimits = this.dataRange.total();\n            var range = this.scaleRange(scale, cursor);\n\n            if (range) {\n                if (range.min < totalLimits.min) {\n                    range.min = totalLimits.min;\n                }\n                if (range.max > totalLimits.max) {\n                    range.max = totalLimits.max;\n                }\n            }\n\n            return range;\n        },\n\n        range: function() {\n            return this.dataRange.displayRange();\n        },\n\n        createLabels: function() {\n            CategoryAxis.fn.createLabels.call(this);\n            this.createRangeLabels();\n        },\n\n        clearLabels: function() {\n            CategoryAxis.fn.clearLabels.call(this);\n            this.rangeLabels = [];\n        },\n\n        arrangeLabels: function() {\n            this.arrangeRangeLabels();\n            CategoryAxis.fn.arrangeLabels.call(this);\n        },\n\n        arrangeRangeLabels: function() {\n            var ref = this;\n            var options = ref.options;\n            var rangeLabels = ref.rangeLabels;\n            if (rangeLabels.length === 0) {\n                return;\n            }\n\n            var lineBox = this.lineBox();\n            var vertical = options.vertical;\n            var mirror = options.rangeLabels.mirror || options.labels.mirror;\n\n            var firstLabel = rangeLabels[0];\n            if (firstLabel) {\n                var position = vertical ? lineBox.y1 - (firstLabel.box.height() / 2) : lineBox.x1;\n                this.positionLabel(firstLabel, mirror, position);\n            }\n\n            var lastLabel = rangeLabels[1];\n            if (lastLabel) {\n                var position$1 = vertical ? lineBox.y2 - (lastLabel.box.height() / 2) : lineBox.x2;\n                this.positionLabel(lastLabel, mirror, position$1);\n            }\n        },\n\n        autoRotateLabels: function() {\n            CategoryAxis.fn.autoRotateLabels.call(this);\n            this.autoRotateRangeLabels();\n        },\n\n        hideOutOfRangeLabels: function() {\n            CategoryAxis.fn.hideOutOfRangeLabels.call(this);\n            this.hideOverlappingLabels();\n        },\n\n        hideOverlappingLabels: function() {\n            var ref = this;\n            var rangeLabels = ref.rangeLabels;\n            var labels = ref.labels;\n            if (rangeLabels.length === 0) {\n                return;\n            }\n\n            function clip(rangeLabel, label) {\n                if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {\n                    label.options.visible = false;\n                    return true;\n                }\n\n                return false;\n            }\n\n            var firstRangeLabel = rangeLabels[0];\n            if (firstRangeLabel && firstRangeLabel.options.visible) {\n                for (var i = 0; i < labels.length; i++) {\n                    var overlaps = clip(firstRangeLabel, labels[i]);\n                    if (!overlaps) {\n                        break;\n                    }\n                }\n            }\n\n            var lastRangeLabel = rangeLabels[1];\n            if (lastRangeLabel && lastRangeLabel.options.visible) {\n                for (var i$1 = labels.length - 1; i$1 > 0; --i$1) {\n                    var overlaps$1 = clip(lastRangeLabel, labels[i$1]);\n                    if (!overlaps$1) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        contentBox: function() {\n            var box = CategoryAxis.fn.contentBox.call(this);\n            var rangeLabels = this.rangeLabels;\n\n            for (var i = 0; i < rangeLabels.length; i++) {\n                var label = rangeLabels[i];\n                if (label.options.visible) {\n                    box.wrap(label.box);\n                }\n            }\n\n            return box;\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            if (labelContext === void 0) { labelContext = {}; }\n\n            var options = this.options;\n            var dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n            var date = this.divisionRange.dateAt(index);\n            var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n\n            labelOptions.format = labelOptions.format || unitFormat;\n            labelContext.dataItem = dataItem;\n\n            var text = this.axisLabelText(date, labelOptions, labelContext);\n            if (text) {\n                return new AxisLabel(date, text, index, dataItem, labelOptions);\n            }\n        },\n\n        createRangeLabels: function() {\n            var this$1$1 = this;\n\n            var ref = this.divisionRange;\n            var displayStart = ref.displayStart;\n            var displayEnd = ref.displayEnd;\n            var options = this.options;\n            var labelOptions = $.extend({}, options.labels, options.rangeLabels, {\n                align: CENTER,\n                zIndex: options.zIndex\n            });\n\n            if (labelOptions.visible !== true) {\n                return;\n            }\n\n            this.normalizeLabelRotation(labelOptions);\n            labelOptions.alignRotation = CENTER;\n\n            if (labelOptions.rotation === \"auto\") {\n                labelOptions.rotation = 0;\n                options.autoRotateRangeLabels = true;\n            }\n\n            var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n            labelOptions.format = labelOptions.format || unitFormat;\n\n            var createLabel = function (index, date, text) {\n                if (text) {\n                    var label = new AxisLabel(date, text, index, null, labelOptions);\n                    this$1$1.append(label);\n                    this$1$1.rangeLabels.push(label);\n                }\n            };\n\n            var startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });\n            createLabel(0, displayStart, startText);\n\n            var endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });\n            createLabel(1, displayEnd, endText);\n        },\n\n        autoRotateRangeLabels: function() {\n            var this$1$1 = this;\n\n            var labels = this.rangeLabels;\n            if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {\n                return;\n            }\n\n            var rotateLabel = function (label, tickPositions, index) {\n                var width = Math.abs(tickPositions[index + 1] - tickPositions[index]) * 2;\n                var angle = this$1$1.autoRotateLabelAngle(label.box, width);\n                if (angle !== 0) {\n                    label.options.rotation = angle;\n                    label.reflow(new Box());\n                }\n            };\n\n            var tickPositions = this.getMajorTickPositions();\n            rotateLabel(labels[0], tickPositions, 0);\n            rotateLabel(labels[1], tickPositions, tickPositions.length - 2);\n        },\n\n        categoryIndex: function(value) {\n            return this.dataRange.valueIndex(value);\n        },\n\n        slot: function(from, to, limit) {\n            var dateRange = this.dataRange;\n            var start = from;\n            var end = to;\n\n            if (start instanceof Date) {\n                start = dateRange.dateIndex(start);\n            }\n\n            if (end instanceof Date) {\n                end = dateRange.dateIndex(end);\n            }\n\n            var slot = this.getSlot(start, end, limit);\n            if (slot) {\n                return slot.toRect();\n            }\n        },\n\n        getSlot: function(a, b, limit) {\n            var start = a;\n            var end = b;\n\n            if (typeof start === OBJECT) {\n                start = this.categoryIndex(start);\n            }\n\n            if (typeof end === OBJECT) {\n                end = this.categoryIndex(end);\n            }\n\n            return CategoryAxis.fn.getSlot.call(this, start, end, limit);\n        },\n\n        valueRange: function() {\n            var options = this.options;\n            var range = categoryRange(options.srcCategories);\n\n            return {\n                min: toDate(range.min),\n                max: toDate(range.max)\n            };\n        },\n\n        categoryAt: function(index, total) {\n            return this.dataRange.dateAt(index, total);\n        },\n\n        categoriesCount: function() {\n            return this.dataRange.valuesCount();\n        },\n\n        rangeIndices: function() {\n            return this.dataRange.displayIndices();\n        },\n\n        labelsBetweenTicks: function() {\n            return !this.divisionRange.options.justified;\n        },\n\n        prepareUserOptions: function() {\n            if (this.isEmpty()) {\n                return;\n            }\n\n            this.options.categories = this.dataRange.values();\n        },\n\n        getCategory: function(point) {\n            var index = this.pointCategoryIndex(point);\n\n            if (index === null) {\n                return null;\n            }\n\n            return this.dataRange.dateAt(index);\n        },\n\n        totalIndex: function(value) {\n            return this.dataRange.totalIndex(value);\n        },\n\n        currentRangeIndices: function() {\n            var range = this.dataRange.valueRange();\n            return {\n                min: this.dataRange.totalIndex(range.min),\n                max: this.dataRange.totalIndex(range.max)\n            };\n        },\n\n        totalRange: function() {\n            return this.dataRange.total();\n        },\n\n        totalRangeIndices: function() {\n            var range = this.dataRange.total();\n            return {\n                min: this.dataRange.totalIndex(range.min),\n                max: this.dataRange.totalIndex(range.max)\n            };\n        },\n\n        totalCount: function() {\n            return this.dataRange.totalCount();\n        },\n\n        isEmpty: function() {\n            return !this.options.srcCategories.length;\n        },\n\n        roundedRange: function() {\n            if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n                return this.range();\n            }\n\n            var options = this.options;\n            var datesRange = categoryRange(options.srcCategories);\n\n            var dateRange = new DateRange(datesRange.min, datesRange.max, $.extend({}, options, {\n                justified: false,\n                roundToBaseUnit: true,\n                justifyEnd: false\n            }));\n\n            return dateRange.displayRange();\n        }\n    });\n\n    setDefaultOptions(DateCategoryAxis, {\n        type: DATE,\n        labels: {\n            dateFormats: DateLabelFormats\n        },\n        rangeLabels: {\n            visible: false\n        },\n        autoBaseUnitSteps: {\n            milliseconds: [ 1, 10, 100 ],\n            seconds: [ 1, 2, 5, 15, 30 ],\n            minutes: [ 1, 2, 5, 15, 30 ],\n            hours: [ 1, 2, 3 ],\n            days: [ 1, 2, 3 ],\n            weeks: [ 1, 2 ],\n            months: [ 1, 2, 3, 6 ],\n            years: [ 1, 2, 3, 5, 10, 25, 50 ]\n        },\n        maxDateGroups: 10\n    });\n\n    function autoAxisMin(min, max, narrow) {\n        if (!min && !max) {\n            return 0;\n        }\n\n        var axisMin;\n\n        if (min >= 0 && max >= 0) {\n            var minValue = min === max ? 0 : min;\n\n            var diff = (max - minValue) / max;\n            if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n                return 0;\n            }\n\n            axisMin = Math.max(0, minValue - ((max - minValue) / 2));\n        } else {\n            axisMin = min;\n        }\n\n        return axisMin;\n    }\n\n    function autoAxisMax(min, max, narrow) {\n        if (!min && !max) {\n            return 1;\n        }\n\n        var axisMax;\n\n        if (min <= 0 && max <= 0) {\n            var maxValue = min === max ? 0 : max;\n\n            var diff = Math.abs((maxValue - min) / maxValue);\n            if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n                return 0;\n            }\n\n            axisMax = Math.min(0, maxValue - ((min - maxValue) / 2));\n        } else {\n            axisMax = max;\n        }\n\n        return axisMax;\n    }\n\n    function floor(value, step) {\n        return round(Math.floor(value / step) * step, DEFAULT_PRECISION);\n    }\n\n    function ceil(value, step) {\n        return round(Math.ceil(value / step) * step, DEFAULT_PRECISION);\n    }\n\n    function limitCoordinate(value) {\n        return Math.max(Math.min(value, COORDINATE_LIMIT), -COORDINATE_LIMIT);\n    }\n\n    var MIN_VALUE_RANGE$1 = Math.pow(10, -DEFAULT_PRECISION + 1);\n\n    var NumericAxis = Axis.extend({\n        init: function(seriesMin, seriesMax, options, chartService) {\n            Axis.fn.init.call(this, $.extend({}, options, {\n                seriesMin: seriesMin,\n                seriesMax: seriesMax\n            }), chartService);\n        },\n\n        initUserOptions: function(options) {\n            var autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);\n            this.totalOptions = totalAxisOptions(autoOptions, options);\n\n            return axisOptions(autoOptions, options);\n        },\n\n        initFields: function() {\n            this.totalMin = this.totalOptions.min;\n            this.totalMax = this.totalOptions.max;\n            this.totalMajorUnit = this.totalOptions.majorUnit;\n            this.seriesMin = this.options.seriesMin;\n            this.seriesMax = this.options.seriesMax;\n        },\n\n        clone: function() {\n            return new NumericAxis(\n                this.seriesMin,\n                this.seriesMax,\n                $.extend({}, this.options),\n                this.chartService\n            );\n        },\n\n        startValue: function() {\n            return 0;\n        },\n\n        range: function() {\n            var options = this.options;\n            return { min: options.min, max: options.max };\n        },\n\n        getDivisions: function(stepValue) {\n            if (stepValue === 0) {\n                return 1;\n            }\n\n            var options = this.options;\n            var range = options.max - options.min;\n\n            return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;\n        },\n\n        getTickPositions: function(unit, skipUnit) {\n            var options = this.options;\n            var ref = this.lineInfo();\n            var axisDir = ref.axisDir;\n            var axisOrigin = ref.axisOrigin;\n            var lineBox = ref.lineBox;\n            var lineSize = ref.lineSize;\n            var range = options.max - options.min;\n            var scale = lineSize / range;\n            var step = unit * scale;\n            var divisions = this.getDivisions(unit);\n            var positions = [];\n            var pos = lineBox[axisOrigin];\n            var skipStep = 0;\n\n            if (skipUnit) {\n                skipStep = skipUnit / unit;\n            }\n\n            for (var idx = 0; idx < divisions; idx++) {\n                if (idx % skipStep !== 0) {\n                    positions.push(round(pos, COORD_PRECISION));\n                }\n\n                pos = pos + step * axisDir;\n            }\n\n            return positions;\n        },\n\n        getMajorTickPositions: function() {\n            return this.getTickPositions(this.options.majorUnit);\n        },\n\n        getMinorTickPositions: function() {\n            return this.getTickPositions(this.options.minorUnit);\n        },\n\n        getSlot: function(a, b, limit) {\n            if (limit === void 0) { limit = false; }\n\n            var options = this.options;\n            var ref = this.lineInfo();\n            var axis = ref.axis;\n            var axisDir = ref.axisDir;\n            var lineBox = ref.lineBox;\n            var lineSize = ref.lineSize;\n            var lineStart = ref.lineStart;\n            var step = axisDir * (lineSize / (options.max - options.min));\n\n            var start = valueOrDefault(a, b || 0);\n            var end = valueOrDefault(b, a || 0);\n\n            if (limit) {\n                start = limitValue(start, options.min, options.max);\n                end = limitValue(end, options.min, options.max);\n            }\n\n            var p1 = Math.min(start, end) - options.min;\n            var p2 = Math.max(start, end) - options.min;\n\n            var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n            slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n            slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n\n            return slotBox;\n        },\n\n        getValue: function(point) {\n            var options = this.options;\n            var max = Number(options.max);\n            var min = Number(options.min);\n            var offset = this.pointOffset(point);\n            var valueOffset = offset * (max - min);\n\n            if (offset < 0 || offset > 1) {\n                return null;\n            }\n\n            var value = min + valueOffset;\n            return round(value, DEFAULT_PRECISION);\n        },\n\n        translateRange: function(delta) {\n            var options = this.options;\n            var vertical = options.vertical;\n            var reverse = options.reverse;\n            var max = options.max;\n            var min = options.min;\n            var ref = this.lineInfo();\n            var lineSize = ref.lineSize;\n            var range = max - min;\n            var scale = lineSize / range;\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if ((vertical || reverse) && !(vertical && reverse )) {\n                offset = -offset;\n            }\n\n            return {\n                min: min + offset,\n                max: max + offset,\n                offset: offset\n            };\n        },\n\n        labelsCount: function() {\n            return this.getDivisions(this.options.majorUnit);\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            var options = this.options;\n            var value = round(options.min + (index * options.majorUnit), DEFAULT_PRECISION);\n            var text = this.axisLabelText(value, labelOptions, labelContext);\n\n            return new AxisLabel(value, text, index, null, labelOptions);\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.range();\n            return range.min <= value && value <= range.max;\n        },\n\n        pan: function(delta) {\n            var range = this.translateRange(delta);\n            return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n        },\n\n        pointsRange: function(start, end) {\n            var startValue = this.getValue(start);\n            var endValue = this.getValue(end);\n            var min = Math.min(startValue, endValue);\n            var max = Math.max(startValue, endValue);\n\n            if (this.isValidRange(min, max)) {\n                return {\n                    min: min,\n                    max: max\n                };\n            }\n        },\n\n        scaleRange: function(scale, cursor) {\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = this.options.max - this.options.min;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = position * delta;\n            var maxDelta = (1 - position) * delta;\n            var min = round(this.options.min + minDelta, DEFAULT_PRECISION);\n            var max = round(this.options.max - maxDelta, DEFAULT_PRECISION);\n\n            if (max - min < MIN_VALUE_RANGE$1) {\n                max = min + MIN_VALUE_RANGE$1;\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        zoomRange: function(scale, cursor) {\n            var ref = this;\n            var totalMin = ref.totalMin;\n            var totalMax = ref.totalMax;\n            var range = this.scaleRange(scale, cursor);\n\n            return {\n                min: limitValue(range.min, totalMin, totalMax),\n                max: limitValue(range.max, totalMin, totalMax),\n                narrowRange: false\n            };\n        },\n\n        isValidRange: function(min, max) {\n            return max - min > MIN_VALUE_RANGE$1;\n        }\n    });\n\n    function autoAxisOptions(seriesMin, seriesMax, options) {\n        var narrowRange = options.narrowRange;\n\n        var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);\n        var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);\n\n        var majorUnit = autoMajorUnit(autoMin, autoMax);\n        var autoOptions = {\n            majorUnit: majorUnit\n        };\n\n        if (options.roundToMajorUnit !== false) {\n            if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {\n                autoMin -= majorUnit;\n            }\n\n            if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {\n                autoMax += majorUnit;\n            }\n        }\n\n        autoOptions.min = floor(autoMin, majorUnit);\n        autoOptions.max = ceil(autoMax, majorUnit);\n\n        return autoOptions;\n    }\n\n    function totalAxisOptions(autoOptions, options) {\n        return {\n            min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,\n            max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,\n            majorUnit: autoOptions.majorUnit\n        };\n    }\n\n    function clearNullValues(options, fields) {\n        for (var idx = 0; idx < fields.length; idx++) {\n            var field = fields[idx];\n            if (options[field] === null) {\n                options[field] = undefined;\n            }\n        }\n    }\n\n    function axisOptions(autoOptions, userOptions) {\n        var options = userOptions;\n        var userSetMin, userSetMax;\n\n        if (userOptions) {\n            clearNullValues(userOptions, [ 'min', 'max' ]);\n\n            userSetMin = defined(userOptions.min);\n            userSetMax = defined(userOptions.max);\n\n            var userSetLimits = userSetMin || userSetMax;\n\n            if (userSetLimits) {\n                if (userOptions.min === userOptions.max) {\n                    if (userOptions.min > 0) {\n                        userOptions.min = 0;\n                    } else {\n                        userOptions.max = 1;\n                    }\n                }\n            }\n\n            if (userOptions.majorUnit) {\n                autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);\n                autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);\n            } else if (userSetLimits) {\n                options = deepExtend(autoOptions, userOptions);\n\n                // Determine an auto major unit after min/max have been set\n                autoOptions.majorUnit = autoMajorUnit(options.min, options.max);\n            }\n        }\n\n        autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;\n\n        var result = deepExtend(autoOptions, options);\n        if (result.min >= result.max) {\n            if (userSetMin && !userSetMax) {\n                result.max = result.min + result.majorUnit;\n            } else if (!userSetMin && userSetMax) {\n                result.min = result.max - result.majorUnit;\n            }\n        }\n\n        return result;\n    }\n\n    function remainderClose(value, divisor, ratio) {\n        var remainder = round(Math.abs(value % divisor), DEFAULT_PRECISION);\n        var threshold = divisor * (1 - ratio);\n\n        return remainder === 0 || remainder > threshold;\n    }\n\n    setDefaultOptions(NumericAxis, {\n        type: \"numeric\",\n        min: 0,\n        max: 1,\n        vertical: true,\n        majorGridLines: {\n            visible: true,\n            width: 1,\n            color: BLACK\n        },\n        labels: {\n            format: \"#.####################\"\n        },\n        zIndex: 1\n    });\n\n    var MIN_VALUE_RANGE = 1000;\n\n    var DateValueAxis = Axis.extend({\n        init: function(seriesMin, seriesMax, axisOptions, chartService) {\n            var min = toDate(seriesMin);\n            var max = toDate(seriesMax);\n\n            var intlService = chartService.intl;\n            var options = axisOptions || {};\n            options = deepExtend(options || {}, {\n                min: parseDate(intlService, options.min),\n                max: parseDate(intlService, options.max),\n                axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue),\n                weekStartDay: firstDay(options, intlService)\n            });\n            options = applyDefaults(min, max, options);\n\n            Axis.fn.init.call(this, options, chartService);\n\n            this.intlService = intlService;\n            this.seriesMin = min;\n            this.seriesMax = max;\n\n            var weekStartDay = options.weekStartDay || 0;\n            this.totalMin = toTime(floorDate(toTime(min) - 1, options.baseUnit, weekStartDay));\n            this.totalMax = toTime(ceilDate(toTime(max) + 1, options.baseUnit, weekStartDay));\n        },\n\n        clone: function() {\n            return new DateValueAxis(this.seriesMin, this.seriesMax, $.extend({}, this.options), this.chartService);\n        },\n\n        range: function() {\n            var options = this.options;\n            return { min: options.min, max: options.max };\n        },\n\n        getDivisions: function(stepValue) {\n            var options = this.options;\n\n            return Math.floor(\n                duration(options.min, options.max, options.baseUnit) / stepValue + 1\n            );\n        },\n\n        getTickPositions: function(step) {\n            var options = this.options;\n            var ref = this.lineInfo();\n            var dir = ref.axisDir;\n            var lineSize = ref.lineSize;\n            var start = ref.lineStart;\n            var divisions = this.getDivisions(step);\n            var timeRange = dateDiff(options.max, options.min);\n            var scale = lineSize / timeRange;\n            var weekStartDay = options.weekStartDay || 0;\n\n            var positions = [ start ];\n            for (var i = 1; i < divisions; i++) {\n                var date = addDuration(options.min, i * step, options.baseUnit, weekStartDay);\n                var pos = start + dateDiff(date, options.min) * scale * dir;\n\n                positions.push(round(pos, COORD_PRECISION));\n            }\n\n            return positions;\n        },\n\n        getMajorTickPositions: function() {\n            return this.getTickPositions(this.options.majorUnit);\n        },\n\n        getMinorTickPositions: function() {\n            return this.getTickPositions(this.options.minorUnit);\n        },\n\n        getSlot: function(a, b, limit) {\n            return NumericAxis.prototype.getSlot.call(\n                this, parseDate(this.intlService, a), parseDate(this.intlService, b), limit\n            );\n        },\n\n        getValue: function(point) {\n            var value = NumericAxis.prototype.getValue.call(this, point);\n\n            return value !== null ? toDate(value) : null;\n        },\n\n        labelsCount: function() {\n            return this.getDivisions(this.options.majorUnit);\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            var options = this.options;\n            var offset = index * options.majorUnit;\n            var weekStartDay = options.weekStartDay || 0;\n            var date = options.min;\n\n            if (offset > 0) {\n                date = addDuration(date, offset, options.baseUnit, weekStartDay);\n            }\n\n            var unitFormat = labelOptions.dateFormats[options.baseUnit];\n            labelOptions.format = labelOptions.format || unitFormat;\n\n            var text = this.axisLabelText(date, labelOptions, labelContext);\n            return new AxisLabel(date, text, index, null, labelOptions);\n        },\n\n        translateRange: function(delta) {\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var vertical = options.vertical;\n            var reverse = options.reverse;\n            var size = vertical ? lineBox.height() : lineBox.width();\n            var range = this.range();\n            var scale = size / dateDiff(range.max, range.min);\n\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n            if ((vertical || reverse) && !(vertical && reverse )) {\n                offset = -offset;\n            }\n\n            var from = addTicks(options.min, offset);\n            var to = addTicks(options.max, offset);\n\n            return {\n                min: from,\n                max: to,\n                offset: offset\n            };\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.range();\n\n            return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;\n        },\n\n        pan: function(delta) {\n            var range = this.translateRange(delta, true);\n            var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);\n\n            if (limittedRange) {\n                return {\n                    min: toDate(limittedRange.min),\n                    max: toDate(limittedRange.max)\n                };\n            }\n        },\n\n        pointsRange: function(start, end) {\n            var startValue = this.getValue(start);\n            var endValue = this.getValue(end);\n            var min = Math.min(startValue, endValue);\n            var max = Math.max(startValue, endValue);\n\n            return {\n                min: toDate(min),\n                max: toDate(max)\n            };\n        },\n\n        scaleRange: function(scale, cursor) {\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = this.options.max - this.options.min;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = position * delta;\n            var maxDelta = (1 - position) * delta;\n            var min = toDate(toTime(this.options.min) + minDelta);\n            var max = toDate(toTime(this.options.max) - maxDelta);\n\n            if (max - min < MIN_VALUE_RANGE) {\n                max = toDate(toTime(min) + MIN_VALUE_RANGE);\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        zoomRange: function(scale, cursor) {\n            var range = this.scaleRange(scale, cursor);\n            var min = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));\n            var max = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));\n\n            return {\n                min: min,\n                max: max\n            };\n        }\n    });\n\n    function timeUnits(delta) {\n        var unit = HOURS;\n\n        if (delta >= TIME_PER_YEAR) {\n            unit = YEARS;\n        } else if (delta >= TIME_PER_MONTH) {\n            unit = MONTHS;\n        } else if (delta >= TIME_PER_WEEK) {\n            unit = WEEKS;\n        } else if (delta >= TIME_PER_DAY) {\n            unit = DAYS;\n        }\n\n        return unit;\n    }\n\n    function applyDefaults(seriesMin, seriesMax, options) {\n        var min = options.min || seriesMin;\n        var max = options.max || seriesMax;\n        var baseUnit = options.baseUnit || (max && min ? timeUnits(absoluteDateDiff(max, min)) : HOURS);\n        var baseUnitTime = TIME_PER_UNIT[baseUnit];\n        var weekStartDay = options.weekStartDay || 0;\n        var autoMin = floorDate(toTime(min) - 1, baseUnit, weekStartDay) || toDate(max);\n        var autoMax = ceilDate(toTime(max) + 1, baseUnit, weekStartDay);\n        var userMajorUnit = options.majorUnit ? options.majorUnit : undefined;\n        var majorUnit = userMajorUnit || ceil(\n            autoMajorUnit(autoMin.getTime(), autoMax.getTime()),\n            baseUnitTime\n        ) / baseUnitTime;\n        var actualUnits = duration(autoMin, autoMax, baseUnit);\n        var totalUnits = ceil(actualUnits, majorUnit);\n        var unitsToAdd = totalUnits - actualUnits;\n        var head = Math.floor(unitsToAdd / 2);\n        var tail = unitsToAdd - head;\n\n        if (!options.baseUnit) {\n            delete options.baseUnit;\n        }\n\n        options.baseUnit = options.baseUnit || baseUnit;\n        options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);\n        options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);\n        options.minorUnit = options.minorUnit || majorUnit / 5;\n        options.majorUnit = majorUnit;\n\n        return options;\n    }\n\n    setDefaultOptions(DateValueAxis, {\n        type: DATE,\n        majorGridLines: {\n            visible: true,\n            width: 1,\n            color: BLACK\n        },\n        labels: {\n            dateFormats: DateLabelFormats\n        }\n    });\n\n    var DEFAULT_MAJOR_UNIT = 10;\n    var MIN_VALUE_RANGE$2 = 1e-6;\n\n    var LogarithmicAxis = Axis.extend({\n        init: function(seriesMin, seriesMax, options, chartService) {\n\n            var axisOptions = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);\n            var base = axisOptions.majorUnit;\n            var autoMax = autoAxisMax$1(seriesMax, base);\n            var autoMin = autoAxisMin$1(seriesMin, seriesMax, axisOptions);\n            var range = initRange(autoMin, autoMax, axisOptions, options);\n\n            axisOptions.max = range.max;\n            axisOptions.min = range.min;\n            axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n\n            Axis.fn.init.call(this, axisOptions, chartService);\n\n            this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n            this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n            this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n            this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n            this.seriesMin = seriesMin;\n            this.seriesMax = seriesMax;\n\n            this.createLabels();\n        },\n\n        clone: function() {\n            return new LogarithmicAxis(\n                this.seriesMin,\n                this.seriesMax,\n                $.extend({}, this.options),\n                this.chartService\n            );\n        },\n\n        startValue: function() {\n            return this.options.min;\n        },\n\n        getSlot: function(a, b, limit) {\n            var ref = this;\n            var options = ref.options;\n            var logMin = ref.logMin;\n            var logMax = ref.logMax;\n            var base = options.majorUnit;\n            var min = options.min;\n            var max = options.max;\n            var ref$1 = this.lineInfo();\n            var axis = ref$1.axis;\n            var axisDir = ref$1.axisDir;\n            var lineBox = ref$1.lineBox;\n            var lineSize = ref$1.lineSize;\n            var lineStart = ref$1.lineStart;\n            var step = axisDir * (lineSize / (logMax - logMin));\n            var start = valueOrDefault(a, b || 1);\n            var end = valueOrDefault(b, a || 1);\n\n            if (start <= 0 || end <= 0) {\n                return null;\n            }\n\n            if (limit) {\n                start = limitValue(start, min, max);\n                end = limitValue(end, min, max);\n            }\n\n            start = log(start, base);\n            end = log(end, base);\n\n            var p1 = Math.min(start, end) - logMin;\n            var p2 = Math.max(start, end) - logMin;\n\n            var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n            slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n            slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n\n            return slotBox;\n        },\n\n        getValue: function(point) {\n            var ref = this;\n            var options = ref.options;\n            var logMin = ref.logMin;\n            var logMax = ref.logMax;\n            var base = options.majorUnit;\n            var ref$1 = this.lineInfo();\n            var axis = ref$1.axis;\n            var axisDir = ref$1.axisDir;\n            var lineStart = ref$1.lineStart;\n            var lineSize = ref$1.lineSize;\n            var step = ((logMax - logMin) / lineSize);\n            var offset = axisDir * (point[axis] - lineStart);\n            var valueOffset = offset * step;\n\n            if (offset < 0 || offset > lineSize) {\n                return null;\n            }\n\n            var value = logMin + valueOffset;\n\n            return round(Math.pow(base, value), DEFAULT_PRECISION);\n        },\n\n        range: function() {\n            var options = this.options;\n            return { min: options.min, max: options.max };\n        },\n\n        translateRange: function(delta) {\n            var ref = this;\n            var options = ref.options;\n            var logMin = ref.logMin;\n            var logMax = ref.logMax;\n            var reverse = options.reverse;\n            var vertical = options.vertical;\n            var base = options.majorUnit;\n            var lineBox = this.lineBox();\n            var size = vertical ? lineBox.height() : lineBox.width();\n            var scale = size / (logMax - logMin);\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if ((vertical || reverse) && !(vertical && reverse )) {\n                offset = -offset;\n            }\n\n            return {\n                min: Math.pow(base, logMin + offset),\n                max: Math.pow(base, logMax + offset),\n                offset: offset\n            };\n        },\n\n        labelsCount: function() {\n            var floorMax = Math.floor(this.logMax);\n            var count = Math.floor(floorMax - this.logMin) + 1;\n\n            return count;\n        },\n\n        getMajorTickPositions: function() {\n            var ticks = [];\n\n            this.traverseMajorTicksPositions(function (position) {\n                ticks.push(position);\n            }, { step: 1, skip: 0 });\n\n            return ticks;\n        },\n\n        createTicks: function(lineGroup) {\n            var options = this.options;\n            var majorTicks = options.majorTicks;\n            var minorTicks = options.minorTicks;\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var lineBox = this.lineBox();\n            var ticks = [];\n            var tickLineOptions = {\n                // TODO\n                // _alignLines: options._alignLines,\n                vertical: vertical\n            };\n\n            function render(tickPosition, tickOptions) {\n                tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                tickLineOptions.position = tickPosition;\n\n                lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n            }\n\n            if (majorTicks.visible) {\n                this.traverseMajorTicksPositions(render, majorTicks);\n            }\n\n            if (minorTicks.visible) {\n                this.traverseMinorTicksPositions(render, minorTicks);\n            }\n\n            return ticks;\n        },\n\n        createGridLines: function(altAxis) {\n            var options = this.options;\n            var minorGridLines = options.minorGridLines;\n            var majorGridLines = options.majorGridLines;\n            var vertical = options.vertical;\n            var lineBox = altAxis.lineBox();\n            var lineOptions = {\n                lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n                lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n                vertical: vertical\n            };\n            var majorTicks = [];\n\n            var container = this.gridLinesVisual();\n            function render(tickPosition, gridLine) {\n                if (!inArray(tickPosition, majorTicks)) {\n                    lineOptions.position = tickPosition;\n                    container.append(createAxisGridLine(lineOptions, gridLine));\n\n                    majorTicks.push(tickPosition);\n                }\n            }\n\n            if (majorGridLines.visible) {\n                this.traverseMajorTicksPositions(render, majorGridLines);\n            }\n\n            if (minorGridLines.visible) {\n                this.traverseMinorTicksPositions(render, minorGridLines);\n            }\n\n            return container.children;\n        },\n\n        traverseMajorTicksPositions: function(callback, tickOptions) {\n            var ref = this.lineInfo();\n            var lineStart = ref.lineStart;\n            var step = ref.step;\n            var ref$1 = this;\n            var logMin = ref$1.logMin;\n            var logMax = ref$1.logMax;\n\n            for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n                var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n                callback(position, tickOptions);\n            }\n        },\n\n        traverseMinorTicksPositions: function(callback, tickOptions) {\n            var this$1$1 = this;\n\n            var ref = this.options;\n            var min = ref.min;\n            var max = ref.max;\n            var minorUnit = ref.minorUnit;\n            var base = ref.majorUnit;\n            var ref$1 = this.lineInfo();\n            var lineStart = ref$1.lineStart;\n            var step = ref$1.step;\n            var ref$2 = this;\n            var logMin = ref$2.logMin;\n            var logMax = ref$2.logMax;\n            var start = Math.floor(logMin);\n\n            for (var power = start; power < logMax; power++) {\n                var minorOptions = this$1$1._minorIntervalOptions(power);\n                for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n                    var value = minorOptions.value + idx * minorOptions.minorStep;\n                    if (value > max) {\n                        break;\n                    }\n                    if (value >= min) {\n                        var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n                        callback(position, tickOptions);\n                    }\n                }\n            }\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            var power = Math.ceil(this.logMin + index);\n            var value = Math.pow(this.options.majorUnit, power);\n            var text = this.axisLabelText(value, labelOptions, labelContext);\n\n            return new AxisLabel(value, text, index, null, labelOptions);\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.range();\n            return range.min <= value && value <= range.max;\n        },\n\n        pan: function(delta) {\n            var range = this.translateRange(delta);\n            return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n        },\n\n        pointsRange: function(start, end) {\n            var startValue = this.getValue(start);\n            var endValue = this.getValue(end);\n            var min = Math.min(startValue, endValue);\n            var max = Math.max(startValue, endValue);\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        scaleRange: function(scale, cursor) {\n            var ref = this.options;\n            var base = ref.majorUnit;\n            var logMin = log(this.options.min, base);\n            var logMax = log(this.options.max, base);\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = logMax - logMin;\n            var delta = this.scaleToDelta(scale, range);\n            var min = Math.pow(base, logMin + position * delta);\n            var max = Math.pow(base, logMax - (1 - position) * delta);\n\n            if (max - min < MIN_VALUE_RANGE$2) {\n                max = min + MIN_VALUE_RANGE$2;\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        zoomRange: function(scale, cursor) {\n            var range = this.scaleRange(scale, cursor);\n            var ref = this;\n            var totalMin = ref.totalMin;\n            var totalMax = ref.totalMax;\n\n            return {\n                min: limitValue(range.min, totalMin, totalMax),\n                max: limitValue(range.max, totalMin, totalMax)\n            };\n        },\n\n        _minorIntervalOptions: function(power) {\n            var ref = this.options;\n            var minorUnit = ref.minorUnit;\n            var base = ref.majorUnit;\n            var value = Math.pow(base, power);\n            var nextValue = Math.pow(base, power + 1);\n            var difference = nextValue - value;\n            var minorStep = difference / minorUnit;\n\n            return {\n                value: value,\n                minorStep: minorStep\n            };\n        },\n\n        lineInfo: function() {\n            var info = Axis.fn.lineInfo.call(this);\n            info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n\n            return info;\n        }\n    });\n\n    function initRange(autoMin, autoMax, axisOptions, options) {\n        var min = axisOptions.min;\n        var max = axisOptions.max;\n\n        if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n            throwNegativeValuesError();\n        }\n\n        if (!defined(options.max)) {\n            max = autoMax;\n        } else if (options.max <= 0) {\n            throwNegativeValuesError();\n        }\n\n        if (!defined(options.min)) {\n            min = autoMin;\n        } else if (options.min <= 0) {\n            throwNegativeValuesError();\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    function autoAxisMin$1(min, max, options) {\n        var base = options.majorUnit;\n        var autoMin = min;\n        if (min <= 0) {\n            autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n        } else if (!options.narrowRange) {\n            autoMin = Math.pow(base, Math.floor(log(min, base)));\n        }\n        return autoMin;\n    }\n\n    function autoAxisMax$1(max, base) {\n        var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n        var autoMax;\n        if (max <= 0) {\n            autoMax = base;\n        } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n            autoMax = Math.pow(base, log(max, base) + 0.2);\n        } else {\n            autoMax = Math.pow(base, Math.ceil(log(max, base)));\n        }\n\n        return autoMax;\n    }\n\n    function throwNegativeValuesError() {\n        throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n    }\n\n    function log(x, base) {\n        return Math.log(x) / Math.log(base);\n    }\n\n    setDefaultOptions(LogarithmicAxis, {\n        type: \"log\",\n        majorUnit: DEFAULT_MAJOR_UNIT,\n        minorUnit: 1,\n        axisCrossingValue: 1,\n        vertical: true,\n        majorGridLines: {\n            visible: true,\n            width: 1,\n            color: BLACK\n        },\n        zIndex: 1,\n        _deferLabels: true\n    });\n\n    var GridLinesMixin = {\n        createGridLines: function(altAxis) {\n            var options = this.options;\n            var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);\n            var gridLines = [];\n            var skipMajor = false;\n            var majorAngles, minorAngles;\n\n            if (options.majorGridLines.visible) {\n                majorAngles = this.majorGridLineAngles(altAxis);\n                skipMajor = true;\n\n                gridLines = this.renderMajorGridLines(\n                    majorAngles, radius, options.majorGridLines\n                );\n            }\n\n            if (options.minorGridLines.visible) {\n                minorAngles = this.minorGridLineAngles(altAxis, skipMajor);\n\n                append(gridLines, this.renderMinorGridLines(\n                    minorAngles, radius, options.minorGridLines, altAxis, skipMajor\n                ));\n            }\n\n            return gridLines;\n        },\n\n        renderMajorGridLines: function(angles, radius, options) {\n            return this.renderGridLines(angles, radius, options);\n        },\n\n        renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {\n            var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);\n            return this.renderGridLines(angles, radius, options, radiusCallback);\n        },\n\n        renderGridLines: function(angles, radius, options, radiusCallback) {\n            var style = {\n                stroke: {\n                    width: options.width,\n                    color: options.color,\n                    dashType: options.dashType\n                }\n            };\n\n            var center = this.box.center();\n            var circle = new Circle([ center.x, center.y ], radius);\n            var container = this.gridLinesVisual();\n\n            for (var i = 0; i < angles.length; i++) {\n                var line = new Path(style);\n                if (radiusCallback) {\n                    circle.radius = radiusCallback(angles[i]);\n                }\n\n                line.moveTo(circle.center)\n                    .lineTo(circle.pointAt(angles[i] + 180));\n\n                container.append(line);\n            }\n\n            return container.children;\n        },\n\n        gridLineAngles: function(altAxis, size, skip, step, skipAngles) {\n            var this$1$1 = this;\n\n            var divs = this.intervals(size, skip, step, skipAngles);\n            var options = altAxis.options;\n            var altAxisVisible = options.visible && (options.line || {}).visible !== false;\n\n            return map(divs, function (d) {\n                var alpha = this$1$1.intervalAngle(d);\n\n                if (!altAxisVisible || alpha !== 90) {\n                    return alpha;\n                }\n            });\n        }\n    };\n\n    var RadarCategoryAxis = CategoryAxis.extend({\n        range: function() {\n            return { min: 0, max: this.options.categories.length };\n        },\n\n        reflow: function(box) {\n            this.box = box;\n            this.reflowLabels();\n        },\n\n        lineBox: function() {\n            return this.box;\n        },\n\n        reflowLabels: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var labels = ref.labels;\n            var labelOptions = ref.options.labels;\n            var skip = labelOptions.skip || 0;\n            var step = labelOptions.step || 1;\n            var measureBox = new Box();\n\n            for (var i = 0; i < labels.length; i++) {\n                labels[i].reflow(measureBox);\n                var labelBox = labels[i].box;\n\n                labels[i].reflow(this$1$1.getSlot(skip + i * step).adjacentBox(\n                    0, labelBox.width(), labelBox.height()\n                ));\n            }\n        },\n\n        intervals: function(size, skipOption, stepOption, skipAngles) {\n            if (skipAngles === void 0) { skipAngles = false; }\n\n            var options = this.options;\n            var categories = options.categories.length;\n            var divCount = categories / size || 1;\n            var divAngle = 360 / divCount;\n            var skip = skipOption || 0;\n            var step = stepOption || 1;\n            var divs = [];\n            var angle = 0;\n\n            for (var i = skip; i < divCount; i += step) {\n                if (options.reverse) {\n                    angle = 360 - i * divAngle;\n                } else {\n                    angle = i * divAngle;\n                }\n\n                angle = round(angle, COORD_PRECISION) % 360;\n\n                if (!(skipAngles && inArray(angle, skipAngles))) {\n                    divs.push(angle);\n                }\n            }\n\n            return divs;\n        },\n\n        majorIntervals: function() {\n            return this.intervals(1);\n        },\n\n        minorIntervals: function() {\n            return this.intervals(0.5);\n        },\n\n        intervalAngle: function(interval) {\n            return (360 + interval + this.options.startAngle) % 360;\n        },\n\n        majorAngles: function() {\n            var this$1$1 = this;\n\n            return map(this.majorIntervals(), function (interval) { return this$1$1.intervalAngle(interval); });\n        },\n\n        createLine: function() {\n            return [];\n        },\n\n        majorGridLineAngles: function(altAxis) {\n            var majorGridLines = this.options.majorGridLines;\n            return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);\n        },\n\n        minorGridLineAngles: function(altAxis, skipMajor) {\n            var ref = this.options;\n            var minorGridLines = ref.minorGridLines;\n            var majorGridLines = ref.majorGridLines;\n            var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;\n\n            return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n        },\n\n        radiusCallback: function(radius, altAxis, skipMajor) {\n            if (altAxis.options.type !== ARC) {\n                var minorAngle = rad(360 / (this.options.categories.length * 2));\n                var minorRadius = Math.cos(minorAngle) * radius;\n                var majorAngles = this.majorAngles();\n\n                var radiusCallback = function(angle) {\n                    if (!skipMajor && inArray(angle, majorAngles)) {\n                        return radius;\n                    }\n\n                    return minorRadius;\n                };\n                return radiusCallback;\n            }\n        },\n\n        createPlotBands: function() {\n            var this$1$1 = this;\n\n            var plotBands = this.options.plotBands || [];\n\n            var group = this._plotbandGroup = new Group({\n                zIndex: -1\n            });\n\n            for (var i = 0; i < plotBands.length; i++) {\n                var band = plotBands[i];\n                var slot = this$1$1.plotBandSlot(band);\n                var singleSlot = this$1$1.getSlot(band.from);\n\n                var head = band.from - Math.floor(band.from);\n                slot.startAngle += head * singleSlot.angle;\n\n                var tail = Math.ceil(band.to) - band.to;\n                slot.angle -= (tail + head) * singleSlot.angle;\n\n                var ring = ShapeBuilder.current.createRing(slot, {\n                    fill: {\n                        color: band.color,\n                        opacity: band.opacity\n                    },\n                    stroke: {\n                        opacity: band.opacity\n                    }\n                });\n                group.append(ring);\n            }\n\n            this.appendVisual(group);\n        },\n\n        plotBandSlot: function(band) {\n            return this.getSlot(band.from, band.to - 1);\n        },\n\n        getSlot: function(from, to) {\n            var options = this.options;\n            var justified = options.justified;\n            var box = this.box;\n            var divs = this.majorAngles();\n            var totalDivs = divs.length;\n            var slotAngle = 360 / totalDivs;\n            var fromValue = from;\n\n            if (options.reverse && !justified) {\n                fromValue = (fromValue + 1) % totalDivs;\n            }\n\n            fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);\n            var slotStart = divs[fromValue];\n\n            if (justified) {\n                slotStart = slotStart - slotAngle / 2;\n\n                if (slotStart < 0) {\n                    slotStart += 360;\n                }\n            }\n\n            var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);\n            var slots = toValue - fromValue + 1;\n            var angle = slotAngle * slots;\n\n            return new Ring(box.center(), 0, box.height() / 2, slotStart, angle);\n        },\n\n        slot: function(from, to) {\n            var slot = this.getSlot(from, to);\n            var startAngle = slot.startAngle + 180;\n            var endAngle = startAngle + slot.angle;\n\n            return new geometry.Arc([ slot.center.x, slot.center.y ], {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: slot.radius,\n                radiusY: slot.radius\n            });\n        },\n\n        pointCategoryIndex: function(point) {\n            var this$1$1 = this;\n\n            var length = this.options.categories.length;\n            var index = null;\n\n            for (var i = 0; i < length; i++) {\n                var slot = this$1$1.getSlot(i);\n                if (slot.containsPoint(point)) {\n                    index = i;\n                    break;\n                }\n            }\n\n            return index;\n        }\n    });\n\n    setDefaultOptions(RadarCategoryAxis, {\n        startAngle: 90,\n        labels: {\n            margin: getSpacing(10)\n        },\n        majorGridLines: {\n            visible: true\n        },\n        justified: true\n    });\n    deepExtend(RadarCategoryAxis.prototype, GridLinesMixin);\n\n    var PolarAxis = Axis.extend({\n        init: function(options, chartService) {\n            Axis.fn.init.call(this, options, chartService);\n\n            var instanceOptions = this.options;\n\n            instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;\n        },\n\n        getDivisions: function(stepValue) {\n            return NumericAxis.prototype.getDivisions.call(this, stepValue) - 1;\n        },\n\n        reflow: function(box) {\n            this.box = box;\n            this.reflowLabels();\n        },\n\n        reflowLabels: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var options = ref.options;\n            var labels = ref.labels;\n            var labelOptions = ref.options.labels;\n            var skip = labelOptions.skip || 0;\n            var step = labelOptions.step || 1;\n\n            var measureBox = new Box();\n            var divs = this.intervals(options.majorUnit, skip, step);\n\n            for (var i = 0; i < labels.length; i++) {\n                labels[i].reflow(measureBox);\n                var labelBox = labels[i].box;\n\n                labels[i].reflow(this$1$1.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));\n            }\n        },\n\n        lineBox: function() {\n            return this.box;\n        },\n\n        intervals: function(size, skipOption, stepOption, skipAngles) {\n            if (skipAngles === void 0) { skipAngles = false; }\n\n            var min = this.options.min;\n            var divisions = this.getDivisions(size);\n            var divs = [];\n            var skip = skipOption || 0;\n            var step = stepOption || 1;\n\n            for (var i = skip; i < divisions; i += step) {\n                var current = (360 + min + i * size) % 360;\n                if (!(skipAngles && inArray(current, skipAngles))) {\n                    divs.push(current);\n                }\n            }\n\n            return divs;\n        },\n\n        majorIntervals: function() {\n            return this.intervals(this.options.majorUnit);\n        },\n\n        minorIntervals: function() {\n            return this.intervals(this.options.minorUnit);\n        },\n\n        intervalAngle: function(i) {\n            return (540 - i - this.options.startAngle) % 360;\n        },\n\n        createLine: function() {\n            return [];\n        },\n\n        majorGridLineAngles: function(altAxis) {\n            var majorGridLines = this.options.majorGridLines;\n            return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);\n        },\n\n        minorGridLineAngles: function(altAxis, skipMajor) {\n            var options = this.options;\n            var minorGridLines = options.minorGridLines;\n            var majorGridLines = options.majorGridLines;\n            var majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;\n\n            return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n        },\n\n        plotBandSlot: function(band) {\n            return this.getSlot(band.from, band.to);\n        },\n\n        getSlot: function(a, b) {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var startAngle = options.startAngle;\n            var start = limitValue(a, options.min, options.max);\n            var end = limitValue(b || start, start, options.max);\n\n            if (options.reverse) {\n                start *= -1;\n                end *= -1;\n            }\n\n            start = (540 - start - startAngle) % 360;\n            end = (540 - end - startAngle) % 360;\n\n            if (end < start) {\n                var tmp = start;\n                start = end;\n                end = tmp;\n            }\n\n            return new Ring(box.center(), 0, box.height() / 2, start, end - start);\n        },\n\n        slot: function(from, to) {\n            if (to === void 0) { to = from; }\n\n            var options = this.options;\n            var start = 360 - options.startAngle;\n            var slot = this.getSlot(from, to);\n            var min = Math.min(from, to);\n            var max = Math.max(from, to);\n            var startAngle, endAngle;\n\n            if (options.reverse) {\n                startAngle = min;\n                endAngle = max;\n            } else {\n                startAngle = 360 - max;\n                endAngle = 360 - min;\n            }\n\n            startAngle = (startAngle + start) % 360;\n            endAngle = (endAngle + start) % 360;\n\n            return new geometry.Arc([ slot.center.x, slot.center.y ], {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: slot.radius,\n                radiusY: slot.radius\n            });\n        },\n\n        getValue: function(point) {\n            var options = this.options;\n            var center = this.box.center();\n            var dx = point.x - center.x;\n            var dy = point.y - center.y;\n            var theta = Math.round(deg(Math.atan2(dy, dx)));\n            var start = options.startAngle;\n\n            if (!options.reverse) {\n                theta *= -1;\n                start *= -1;\n            }\n\n            return (theta + start + 360) % 360;\n        },\n\n        valueRange: function() {\n            return {\n                min: 0,\n                max: Math.PI * 2\n            };\n        }\n    });\n\n    setDefaultOptions(PolarAxis, {\n        type: \"polar\",\n        startAngle: 0,\n        reverse: false,\n        majorUnit: 60,\n        min: 0,\n        max: 360,\n        labels: {\n            margin: getSpacing(10)\n        },\n        majorGridLines: {\n            color: BLACK,\n            visible: true,\n            width: 1\n        },\n        minorGridLines: {\n            color: \"#aaa\"\n        }\n    });\n\n    deepExtend(PolarAxis.prototype, GridLinesMixin, {\n        createPlotBands: RadarCategoryAxis.prototype.createPlotBands,\n        majorAngles: RadarCategoryAxis.prototype.majorAngles,\n        range: NumericAxis.prototype.range,\n        labelsCount: NumericAxis.prototype.labelsCount,\n        createAxisLabel: NumericAxis.prototype.createAxisLabel\n    });\n\n    var RadarNumericAxisMixin = {\n        options: {\n            majorGridLines: {\n                visible: true\n            }\n        },\n\n        createPlotBands: function() {\n            var this$1$1 = this;\n\n            var ref = this.options;\n            var type = ref.majorGridLines.type;\n            var plotBands = ref.plotBands; if (plotBands === void 0) { plotBands = []; }\n            var altAxis = this.plotArea.polarAxis;\n            var majorAngles = altAxis.majorAngles();\n            var center = altAxis.box.center();\n            var group = this._plotbandGroup = new Group({\n                zIndex: -1\n            });\n\n            for (var i = 0; i < plotBands.length; i++) {\n                var band = plotBands[i];\n                var bandStyle = {\n                    fill: {\n                        color: band.color,\n                        opacity: band.opacity\n                    },\n                    stroke: {\n                        opacity: band.opacity\n                    }\n                };\n\n                var slot = this$1$1.getSlot(band.from, band.to, true);\n                var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n\n                var shape = (void 0);\n                if (type === ARC) {\n                    shape = ShapeBuilder.current.createRing(ring, bandStyle);\n                } else {\n                    shape = Path.fromPoints(this$1$1.plotBandPoints(ring, majorAngles), bandStyle).close();\n                }\n\n                group.append(shape);\n            }\n\n            this.appendVisual(group);\n        },\n\n        plotBandPoints: function(ring, angles) {\n            var innerPoints = [];\n            var outerPoints = [];\n            var center = [ ring.center.x, ring.center.y ];\n            var innerCircle = new Circle(center, ring.innerRadius);\n            var outerCircle = new Circle(center, ring.radius);\n\n            for (var i = 0; i < angles.length; i++) {\n                innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n                outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n            }\n\n            innerPoints.reverse();\n            innerPoints.push(innerPoints[0]);\n            outerPoints.push(outerPoints[0]);\n\n            return outerPoints.concat(innerPoints);\n        },\n\n        createGridLines: function(altAxis) {\n            var options = this.options;\n            var majorTicks = this.radarMajorGridLinePositions();\n            var majorAngles = altAxis.majorAngles();\n            var center = altAxis.box.center();\n            var gridLines = [];\n\n            if (options.majorGridLines.visible) {\n                gridLines = this.renderGridLines(\n                    center, majorTicks, majorAngles, options.majorGridLines\n                );\n            }\n\n            if (options.minorGridLines.visible) {\n                var minorTicks = this.radarMinorGridLinePositions();\n                append(gridLines, this.renderGridLines(\n                    center, minorTicks, majorAngles, options.minorGridLines\n                ));\n            }\n\n            return gridLines;\n        },\n\n        renderGridLines: function(center, ticks, angles, options) {\n            var style = {\n                stroke: {\n                    width: options.width,\n                    color: options.color,\n                    dashType: options.dashType\n                }\n            };\n            var skip = options.skip; if (skip === void 0) { skip = 0; }\n            var step = options.step; if (step === void 0) { step = 0; }\n            var container = this.gridLinesVisual();\n\n            for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {\n                var tickRadius = center.y - ticks[tickIx];\n                if (tickRadius > 0) {\n                    var circle = new Circle([ center.x, center.y ], tickRadius);\n                    if (options.type === ARC) {\n                        container.append(new drawing.Circle(circle, style));\n                    } else {\n                        var line = new Path(style);\n                        for (var angleIx = 0; angleIx < angles.length; angleIx++) {\n                            line.lineTo(circle.pointAt(angles[angleIx] + 180));\n                        }\n\n                        line.close();\n                        container.append(line);\n                    }\n                }\n            }\n\n            return container.children;\n        },\n\n        getValue: function(point) {\n            var lineBox = this.lineBox();\n            var altAxis = this.plotArea.polarAxis;\n            var majorAngles = altAxis.majorAngles();\n            var center = altAxis.box.center();\n            var radius = point.distanceTo(center);\n            var distance = radius;\n\n            if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n                var dx = point.x - center.x;\n                var dy = point.y - center.y;\n                var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n\n                majorAngles.sort(function(a, b) {\n                    return angularDistance(a, theta) - angularDistance(b, theta);\n                });\n\n                // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n                // Angles are derived from triangle (center, point, gridline X)\n                var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n                var alpha = angularDistance(theta, majorAngles[0]);\n                var gamma = 90 - midAngle;\n                var beta = 180 - alpha - gamma;\n\n                distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n            }\n\n            return this.axisType().prototype.getValue.call(\n                this, new Point(lineBox.x1, lineBox.y2 - distance)\n            );\n        }\n    };\n\n    function angularDistance(a, b) {\n        return 180 - Math.abs(Math.abs(a - b) - 180);\n    }\n\n    var RadarNumericAxis = NumericAxis.extend({\n        radarMajorGridLinePositions: function() {\n            return this.getTickPositions(this.options.majorUnit);\n        },\n\n        radarMinorGridLinePositions: function() {\n            var options = this.options;\n            var minorSkipStep = 0;\n\n            if (options.majorGridLines.visible) {\n                minorSkipStep = options.majorUnit;\n            }\n            return this.getTickPositions(options.minorUnit, minorSkipStep);\n        },\n\n        axisType: function() {\n            return NumericAxis;\n        }\n    });\n\n    deepExtend(RadarNumericAxis.prototype, RadarNumericAxisMixin);\n\n    var RadarLogarithmicAxis = LogarithmicAxis.extend({\n        radarMajorGridLinePositions: function() {\n            var positions = [];\n\n            this.traverseMajorTicksPositions(function(position) {\n                positions.push(position);\n            }, this.options.majorGridLines);\n\n            return positions;\n        },\n\n        radarMinorGridLinePositions: function() {\n            var positions = [];\n\n            this.traverseMinorTicksPositions(function(position) {\n                positions.push(position);\n            }, this.options.minorGridLines);\n\n            return positions;\n        },\n\n        axisType: function() {\n            return LogarithmicAxis;\n        }\n    });\n\n    deepExtend(RadarLogarithmicAxis.prototype, RadarNumericAxisMixin);\n\n    var WEIGHT = 0.333;\n    var EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\n    var CurveProcessor = Class.extend({\n        init: function(closed) {\n\n            this.closed = closed;\n        },\n\n        process: function(dataPoints) {\n            var this$1$1 = this;\n\n            var points = dataPoints.slice(0);\n            var segments = [];\n            var closed = this.closed;\n            var length = points.length;\n\n            if (length > 2) {\n                this.removeDuplicates(0, points);\n                length = points.length;\n            }\n\n            if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n                return segments;\n            }\n\n            var p0 = points[0];\n            var p1 = points[1];\n            var p2 = points[2];\n\n            segments.push(new Segment(p0));\n\n            while (p0.equals(points[length - 1])) {\n                closed = true;\n                points.pop();\n                length--;\n            }\n\n            if (length === 2) {\n                var tangent = this.tangent(p0,p1, X, Y);\n\n                last(segments).controlOut(\n                    this.firstControlPoint(tangent, p0, p1, X, Y)\n                );\n\n                segments.push(new Segment(\n                    p1,\n                    this.secondControlPoint(tangent, p0, p1, X, Y)\n                ));\n\n                return segments;\n            }\n\n            var initialControlPoint, lastControlPoint;\n\n            if (closed) {\n                p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n                var controlPoints = this.controlPoints(p0, p1, p2);\n                initialControlPoint = controlPoints[1];\n                lastControlPoint = controlPoints[0];\n            } else {\n                var tangent$1 = this.tangent(p0, p1, X,Y);\n                initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n            }\n\n            var cp0 = initialControlPoint;\n            for (var idx = 0; idx <= length - 3; idx++) {\n                this$1$1.removeDuplicates(idx, points);\n                length = points.length;\n                if (idx + 3 <= length) {\n                    p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n                    var controlPoints$1 = this$1$1.controlPoints(p0,p1,p2);\n\n                    last(segments).controlOut(cp0);\n                    cp0 = controlPoints$1[1];\n\n                    var cp1 = controlPoints$1[0];\n                    segments.push(new Segment(p1, cp1));\n                }\n            }\n\n            if (closed) {\n                p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n                var controlPoints$2 = this.controlPoints(p0, p1, p2);\n\n                last(segments).controlOut(cp0);\n                segments.push(new Segment(\n                    p1,\n                    controlPoints$2[0]\n                ));\n\n                last(segments).controlOut(controlPoints$2[1]);\n                segments.push(new Segment(\n                    p2,\n                    lastControlPoint\n                ));\n            } else {\n                var tangent$2 = this.tangent(p1, p2, X, Y);\n\n                last(segments).controlOut(cp0);\n                segments.push(new Segment(\n                    p2,\n                    this.secondControlPoint(tangent$2, p1, p2, X, Y)\n                ));\n            }\n\n            return segments;\n        },\n\n        removeDuplicates: function(idx, points) {\n            while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n                points.splice(idx + 1, 1);\n            }\n        },\n\n        invertAxis: function(p0, p1, p2) {\n            var invertAxis = false;\n\n            if (p0.x === p1.x) {\n                invertAxis = true;\n            } else if (p1.x === p2.x) {\n                if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n                    invertAxis = true;\n                }\n            } else {\n                var fn = this.lineFunction(p0,p1);\n                var y2 = this.calculateFunction(fn, p2.x);\n                if (!(p0.y <= p1.y && p2.y <= y2) &&\n                    !(p1.y <= p0.y && p2.y >= y2)) {\n                    invertAxis = true;\n                }\n            }\n\n            return invertAxis;\n        },\n\n        isLine: function(p0, p1, p2) {\n            var fn = this.lineFunction(p0, p1);\n            var y2 = this.calculateFunction(fn, p2.x);\n\n            return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n        },\n\n        lineFunction: function(p1, p2) {\n            var a = (p2.y - p1.y) / (p2.x - p1.x);\n            var b = p1.y - a * p1.x;\n\n            return [ b, a ];\n        },\n\n        controlPoints: function(p0, p1, p2) {\n            var xField = X;\n            var yField = Y;\n            var restrict = false;\n            var switchOrientation = false;\n            var tangent;\n\n            if (this.isLine(p0, p1, p2)) {\n                tangent = this.tangent(p0, p1, X, Y);\n            } else {\n                var monotonic = {\n                    x: this.isMonotonicByField(p0, p1, p2, X),\n                    y: this.isMonotonicByField(p0, p1, p2, Y)\n                };\n\n                if (monotonic.x && monotonic.y) {\n                    tangent = this.tangent(p0, p2, X, Y);\n                    restrict = true;\n                } else {\n                    if (this.invertAxis(p0, p1, p2)) {\n                        xField = Y;\n                        yField = X;\n                    }\n\n                    if (monotonic[xField]) {\n                        tangent = 0;\n                    } else {\n                        var sign;\n                        if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n                            (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n                            sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                        } else {\n                            sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                        }\n\n                        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                        switchOrientation = true;\n                    }\n                }\n            }\n\n            var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n            if (switchOrientation) {\n                var oldXField = xField;\n                xField = yField;\n                yField = oldXField;\n            }\n\n            var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n            if (restrict) {\n                this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n                this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n            }\n\n            return [ secondControlPoint, firstControlPoint ];\n        },\n\n        restrictControlPoint: function(p1, p2, cp, tangent) {\n            if (p1.y < p2.y) {\n                if (p2.y < cp.y) {\n                    cp.x = p1.x + (p2.y - p1.y) / tangent;\n                    cp.y = p2.y;\n                } else if (cp.y < p1.y) {\n                    cp.x = p2.x - (p2.y - p1.y) / tangent;\n                    cp.y = p1.y;\n                }\n            } else {\n                if (cp.y < p2.y) {\n                    cp.x = p1.x - (p1.y - p2.y) / tangent;\n                    cp.y = p2.y;\n                } else if (p1.y < cp.y) {\n                    cp.x = p2.x + (p1.y - p2.y) / tangent;\n                    cp.y = p1.y;\n                }\n            }\n        },\n\n        tangent: function(p0, p1, xField, yField) {\n            var x = p1[xField] - p0[xField];\n            var y = p1[yField] - p0[yField];\n            var tangent;\n\n            if (x === 0) {\n                tangent = 0;\n            } else {\n                tangent = y / x;\n            }\n\n            return tangent;\n        },\n\n        isMonotonicByField: function(p0, p1, p2, field) {\n            return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n                        (p2[field] < p1[field] && p1[field] < p0[field]);\n        },\n\n        firstControlPoint: function(tangent, p0, p3, xField, yField) {\n            var t1 = p0[xField];\n            var t2 = p3[xField];\n            var distance = (t2 - t1) * WEIGHT;\n\n            return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n        },\n\n        secondControlPoint: function(tangent, p0, p3, xField, yField) {\n            var t1 = p0[xField];\n            var t2 = p3[xField];\n            var distance = (t2 - t1) * WEIGHT;\n\n            return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n        },\n\n        point: function(xValue, yValue, xField, yField) {\n            var controlPoint = new geometry.Point();\n            controlPoint[xField] = xValue;\n            controlPoint[yField] = yValue;\n\n            return controlPoint;\n        },\n\n        calculateFunction: function(fn, x) {\n            var length = fn.length;\n            var result = 0;\n\n            for (var i = 0; i < length; i++) {\n                result += Math.pow(x,i) * fn[i];\n            }\n            return result;\n        }\n    });\n\n    function numberSign(value) {\n        return value <= 0 ? -1 : 1;\n    }\n\n    dataviz.Gradients = GRADIENTS;\n\n    kendo.deepExtend(kendo.dataviz, {\n        constants: constants,\n        services: services,\n        autoMajorUnit: autoMajorUnit,\n        Point: Point,\n        Box: Box,\n        Ring: Ring,\n        Sector: Sector,\n        ShapeBuilder: ShapeBuilder,\n        ShapeElement: ShapeElement,\n        ChartElement: ChartElement,\n        BoxElement: BoxElement,\n        RootElement: RootElement,\n        FloatElement: FloatElement,\n        Text: Text,\n        TextBox: TextBox,\n        Title: Title,\n        AxisLabel: AxisLabel,\n        Axis: Axis,\n        Note: Note,\n        CategoryAxis: CategoryAxis,\n        DateCategoryAxis: DateCategoryAxis,\n        DateValueAxis: DateValueAxis,\n        NumericAxis: NumericAxis,\n        LogarithmicAxis: LogarithmicAxis,\n        PolarAxis: PolarAxis,\n        RadarCategoryAxis: RadarCategoryAxis,\n        RadarNumericAxis: RadarNumericAxis,\n        RadarLogarithmicAxis: RadarLogarithmicAxis,\n        CurveProcessor: CurveProcessor,\n        rectToBox: rectToBox,\n        addClass: addClass,\n        removeClass: removeClass,\n        alignPathToPixel: alignPathToPixel,\n        clockwise: clockwise,\n        convertableToNumber: convertableToNumber,\n        cycleUp: cycleUp,\n        cycleDown: cycleDown,\n        cycleIndex: cycleIndex,\n        deepExtend: deepExtend,\n        elementStyles: elementStyles,\n        getSpacing: getSpacing,\n        getTemplate: getTemplate,\n        getAriaTemplate: getTemplate$1,\n        getter: __common_getter_js,\n        grep: grep,\n        hasClasses: hasClasses,\n        HashMap: HashMap,\n        inArray: inArray,\n        interpolateValue: interpolateValue,\n        InstanceObserver: InstanceObserver,\n        isArray: isArray,\n        isFunction: isFunction,\n        isNumber: isNumber,\n        isObject: isObject,\n        isPlainObject: isPlainObject,\n        isString: isString,\n        map: map,\n        mousewheelDelta: mousewheelDelta,\n        FontLoader: FontLoader,\n        renderIcon: renderIcon,\n        setDefaultOptions: setDefaultOptions,\n        sparseArrayLimits: sparseArrayLimits,\n        styleValue: styleValue,\n        find: find,\n        elementScale: elementScale,\n        autoTextColor: autoTextColor,\n        createHashSet: createHashSet,\n        defaultErrorHandler: defaultErrorHandler,\n        keys: keys,\n        hasOwnProperty: hasOwnProperty,\n        Matrix: Matrix$1,\n        append: append,\n        bindEvents: bindEvents,\n        Class: Class,\n        defined: defined,\n        deg: deg,\n        elementOffset: elementOffset,\n        elementSize: elementSize,\n        eventCoordinates: eventCoordinates,\n        eventElement: eventElement,\n        hashKey: hashKey,\n        last: last,\n        limitValue: limitValue,\n        logToConsole: kendo.logToConsole,\n        objectKey: objectKey,\n        rad: rad,\n        round: round,\n        unbindEvents: unbindEvents,\n        valueOrDefault: valueOrDefault,\n        absoluteDateDiff: absoluteDateDiff,\n        addDuration: addDuration,\n        addTicks: addTicks,\n        ceilDate: ceilDate,\n        dateComparer: dateComparer,\n        dateDiff: dateDiff,\n        dateEquals: dateEquals,\n        dateIndex: dateIndex,\n        duration: duration,\n        floorDate: floorDate,\n        lteDateIndex: lteDateIndex,\n        startOfWeek: startOfWeek,\n        toDate: toDate,\n        parseDate: parseDate,\n        parseDates: parseDates,\n        toTime: toTime,\n        firstDay: firstDay\n    });\n\n    })(window.kendo.jQuery);\n\n    (function($) {\n\n        var dataviz = kendo.dataviz;\n        var services = dataviz.services;\n        var draw = kendo.drawing;\n\n        dataviz.SASS_THEMES = [\"sass\", \"default-v2\", \"bootstrap-v4\", \"material-v2\"];\n\n        dataviz.ExportMixin = {\n            extend: function(proto, skipLegacy) {\n                if (!proto.exportVisual) {\n                    throw new Error(\"Mixin target has no exportVisual method defined.\");\n                }\n\n                proto.exportSVG = this.exportSVG;\n                proto.exportImage = this.exportImage;\n                proto.exportPDF = this.exportPDF;\n\n                if (!skipLegacy) {\n                    proto.svg = this.svg;\n                    proto.imageDataURL = this.imageDataURL;\n                }\n            },\n\n            exportSVG: function(options) {\n                return draw.exportSVG(this.exportVisual(), options);\n            },\n\n            exportImage: function(options) {\n                return draw.exportImage(this.exportVisual(options), options);\n            },\n\n            exportPDF: function(options) {\n                return draw.exportPDF(this.exportVisual(), options);\n            },\n\n            svg: function() {\n                if (draw.svg.Surface) {\n                    return draw.svg.exportGroup(this.exportVisual());\n                } else {\n                    throw new Error(\"SVG Export failed. Unable to export instantiate kendo.drawing.svg.Surface\");\n                }\n            },\n\n            imageDataURL: function() {\n                if (!kendo.support.canvas) {\n                    return null;\n                }\n\n                if (draw.canvas.Surface) {\n                    var container = $(\"<div />\").css({\n                        display: \"none\",\n                        width: this.element.width(),\n                        height: this.element.height()\n                    }).appendTo(document.body);\n\n                    var surface = new draw.canvas.Surface(container[0]);\n                    surface.draw(this.exportVisual());\n                    var image = surface._rootElement.toDataURL();\n\n                    surface.destroy();\n                    container.remove();\n\n                    return image;\n                } else {\n                    throw new Error(\"Image Export failed. Unable to export instantiate kendo.drawing.canvas.Surface\");\n                }\n            }\n        };\n\n        services.IntlService.register({\n           format: function(format) {\n               return kendo.format.apply(null, [format].concat(Array.prototype.slice.call(arguments, 1)));\n           },\n           toString: kendo.toString,\n           parseDate: kendo.parseDate,\n           firstDay: function() {\n               return kendo.culture().calendars.standard.firstDay;\n           }\n        });\n\n        services.TemplateService.register({\n           compile: kendo.template\n        });\n\n        dataviz.Point2D = dataviz.Point;\n        dataviz.Box2D = dataviz.Box;\n        dataviz.mwDelta = function(e) {\n            return dataviz.mousewheelDelta(e.originalEvent);\n        };\n\n    })(window.kendo.jQuery);\n\n    var __meta__ = {\n        id: \"dataviz.core\",\n        name: \"Core\",\n        description: \"The DataViz core functions\",\n        category: \"dataviz\",\n        depends: [ \"core\", \"drawing\" ],\n        hidden: true\n    };\n\n    var kendo$1 = kendo;\n\n    return kendo$1;\n\n}));\n"]}